<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Ventilation Control Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script>
        // Authentication check - redirect to login if not authenticated
        window.addEventListener('load', function() {
            const token = localStorage.getItem('ventilation_auth_token');
            const apiKey = getApiKeyFromUrl();
            
            // If no token and no API key, show no data message (don't redirect)
            // This allows users to see the dashboard structure before logging in
            if (!token && !apiKey) {
                // Show no data state without authentication
                return;
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .subtitle {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }

        .status-indicator.online {
            background: #28a745;
        }

        .refresh-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .refresh-btn:hover {
            background: #0056b3;
        }

        .main-content {
            padding: 30px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }

        .card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .sensor-reading {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .sensor-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #2c3e50;
        }

        .temperature {
            color: #e74c3c;
        }

        .humidity {
            color: #3498db;
        }

        .pressure {
            color: #9b59b6;
        }

        .system-status {
            text-align: center;
            padding: 20px;
        }

        .fan-status {
            font-size: 3em;
            margin: 20px 0;
        }

        .fan-on {
            color: #28a745;
        }

        .fan-off {
            color: #dc3545;
        }

        .door-item {
            font-size: 0.95em;
        }

        .door-detail {
            margin: 8px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .door-detail strong {
            color: #2c3e50;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }

        .time-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .time-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .time-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .time-btn:hover {
            background: #e9ecef;
        }

        .time-btn.active:hover {
            background: #0056b3;
        }

        .alert-section {
            margin-top: 30px;
        }

        .alert {
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-danger {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .incident-item {
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .incident-critical {
            background: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }

        .incident-high {
            background: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }

        .incident-medium {
            background: #cce7ff;
            border-left-color: #007bff;
            color: #004085;
        }

        .incident-low {
            background: #f8f9fa;
            border-left-color: #6c757d;
            color: #495057;
        }

        .incident-header {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .incident-details {
            font-size: 0.85em;
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        .error {
            text-align: center;
            padding: 50px;
            color: #dc3545;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                align-items: stretch;
            }
            
            .time-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- test edit -->
    <div class="container">
        <div class="header">
            <h1>üåÄ ESP32 Ventilation Control</h1>
            <p class="subtitle">Real-time Environmental Monitoring & Control Dashboard</p>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="connectionStatus"></div>
                <span id="connectionText">Connecting...</span>
            </div>
            <div class="status-item">
                <span>Last Update: <span id="lastUpdate">-</span></span>
            </div>
            <button class="refresh-btn" onclick="refreshData()">üîÑ Refresh</button>
        </div>

        <div class="main-content">
            <div id="loadingSection" class="loading">
                <h3>Loading ventilation data...</h3>
                <p>Please wait while we fetch the latest information.</p>
            </div>

            <div id="errorSection" class="error" style="display: none;">
                <h3>‚ö†Ô∏è Connection Error</h3>
                <p>Unable to connect to the ventilation system. Please check your API endpoints.</p>
                <button class="refresh-btn" onclick="refreshData()">Try Again</button>
            </div>

            <div id="dashboardContent" style="display: none;">
                <!-- Current Status Grid -->
                <div class="grid">
                    <!-- Indoor Sensors -->
                    <div class="card">
                        <h3>üè† Indoor Environment</h3>
                        <div class="sensor-reading">
                            <span>Temperature</span>
                            <span class="sensor-value temperature" id="indoorTemp">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Humidity</span>
                            <span class="sensor-value humidity" id="indoorHumidity">-%</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Pressure</span>
                            <span class="sensor-value pressure" id="indoorPressure">- inHg</span>
                        </div>
                    </div>

                    <!-- Outdoor Sensors -->
                    <div class="card">
                        <h3>üå§Ô∏è Outdoor Environment</h3>
                        <div class="sensor-reading">
                            <span>Temperature</span>
                            <span class="sensor-value temperature" id="outdoorTemp">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Humidity</span>
                            <span class="sensor-value humidity" id="outdoorHumidity">-%</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Pressure</span>
                            <span class="sensor-value pressure" id="outdoorPressure">- inHg</span>
                        </div>
                    </div>

                    <!-- Garage Sensors -->
                    <div class="card">
                        <h3>üè† Garage Environment</h3>
                        <div class="sensor-reading">
                            <span>Temperature</span>
                            <span class="sensor-value temperature" id="garageTemp">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Humidity</span>
                            <span class="sensor-value humidity" id="garageHumidity">-%</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Pressure</span>
                            <span class="sensor-value pressure" id="garagePressure">- inHg</span>
                        </div>
                    </div>

                    <!-- System Status -->
                    <div class="card">
                        <h3>‚öôÔ∏è System Status</h3>
                        <div class="system-status">
                            <div class="fan-status" id="fanStatus">üåÄ</div>
                            <div><strong id="fanStatusText">System Status</strong></div>
                            <div style="margin-top: 15px;">
                                <div>Mode: <strong id="ventilationMode">-</strong></div>
                                <div>Runtime Today: <strong id="fanMinutes">0</strong> minutes</div>
                                <div>Fresh Air: <strong id="freshAirStatus">-</strong></div>
                                <div>Operating Hours: <strong id="ventilationHours">-</strong></div>
                                <div>Cooling Effect: <strong id="coolingEffect">-</strong></div>
                            </div>
                        </div>
                    </div>

                    <!-- Weather & Forecast -->
                    <div class="card">
                        <h3>üìä Weather & Forecast</h3>
                        <div class="sensor-reading">
                            <span>Forecast High</span>
                            <span class="sensor-value temperature" id="forecastHigh">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Storm Risk</span>
                            <span class="sensor-value" id="stormRisk">-</span>
                        </div>
                        <div id="stormRiskExplanation" style="font-size: 12px; color: #666; margin-top: 10px; font-style: italic;">
                            Storm risk status will be explained here.
                        </div>
                    </div>
                </div>

                    <!-- System Incidents -->
                <div class="card">
                    <h3>ÔøΩ System Incidents (Last 30 Days)</h3>
                    
                    <!-- System Overview -->
                    <div style="margin-bottom: 15px; padding: 10px; background: #f0f8ff; border-radius: 5px; font-size: 0.9em; color: #444; border-left: 4px solid #007bff;">
                        <strong>System Overview:</strong> 
                        Uptime: <span id="uptime">-</span> | 
                        Total Reboots: <span id="rebootCount">-</span> | 
                        WiFi Outages: <span id="wifiOutageCount">-</span>
                    </div>
                    
                    <div id="incidentsList"></div>
                    <div id="incidentsSummary" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 0.9em; color: #666;">
                        Loading incident data...
                    </div>
                </div>

                <!-- Historical Charts -->
                <div class="card">
                    <h3>üìà Historical Data</h3>
                    <div class="time-controls">
                        <button class="time-btn active" onclick="loadChart(6)">6 Hours</button>
                        <button class="time-btn" onclick="loadChart(24)">24 Hours</button>
                        <button class="time-btn" onclick="loadChart(72)">3 Days</button>
                        <button class="time-btn" onclick="loadChart(168)">1 Week</button>
                    </div>
                    <div class="chart-container">
                        <canvas id="temperatureChart"></canvas>
                    </div>
                </div>

                <!-- Door Status -->
                <div class="card" id="doorSection" style="display: none;">
                    <h3>üö™ Door Status & Activity</h3>
                    <div id="doorList"></div>
                </div>

                <!-- Alerts -->
                <div class="alert-section" id="alertSection" style="display: none;">
                    <div class="card">
                        <h3>‚ö†Ô∏è System Alerts</h3>
                        <div id="alertList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration - Replace with your actual Azure Function URLs
        const CONFIG = {
            statusApiUrl: 'https://esp32-ventilation-api.azurewebsites.net/api/GetVentilationStatus',
            historyApiUrl: 'https://esp32-ventilation-api.azurewebsites.net/api/GetVentilationHistory',
            deviceId: 'ESP32-Ventilation-01',
            refreshInterval: 30000, // 30 seconds - check for new telemetry data
            apiSecret: getApiKeyFromUrl() || null // Get from URL parameter or environment
        };

        // Helper function to get API key from URL parameter
        function getApiKeyFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('apikey') || urlParams.get('key');
        }

        let temperatureChart = null;
        let refreshTimer = null;
        let currentChartHours = 6; // Track the currently displayed time period
        let latestChartDataTimestamp = null; // Track the latest data point timestamp to avoid unnecessary chart refreshes

        // Authentication and API helper functions
        function getAuthHeaders() {
            const token = localStorage.getItem('ventilation_auth_token');
            const headers = {
                'Content-Type': 'application/json'
            };
            
            // If user is logged in, use Bearer token authentication
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            // Otherwise, use API key if available
            else if (CONFIG.apiSecret) {
                headers['X-API-Secret'] = CONFIG.apiSecret;
            }
            
            return headers;
        }

        function logout() {
            localStorage.removeItem('ventilation_auth_token');
            localStorage.removeItem('ventilation_user_email');
            window.location.href = 'login.html';
        }

        // Function to show API failure notifications
        function showApiFailureNotice(message, type = 'warning') {
            // Remove any existing notices
            const existingNotice = document.querySelector('.api-failure-notice');
            if (existingNotice) {
                existingNotice.remove();
            }

            const header = document.querySelector('.header');
            const notice = document.createElement('div');
            notice.className = 'api-failure-notice';
            notice.style.cssText = `
                background: ${type === 'error' ? 'rgba(220,53,69,0.9)' : 'rgba(255,193,7,0.9)'};
                color: ${type === 'error' ? 'white' : '#212529'};
                padding: 12px 15px;
                text-align: center;
                font-size: 0.9em;
                border-radius: 5px;
                margin-top: 15px;
                border: 1px solid ${type === 'error' ? 'rgba(220,53,69,0.5)' : 'rgba(255,193,7,0.5)'};
                animation: slideDown 0.3s ease-out;
            `;
            notice.innerHTML = `
                <strong>${type === 'error' ? '‚ö†Ô∏è API Error:' : '‚ö†Ô∏è Data Unavailable:'}</strong> ${message}
                <button onclick="this.parentElement.remove()" style="
                    float: right;
                    background: transparent;
                    border: none;
                    color: inherit;
                    font-size: 16px;
                    cursor: pointer;
                    padding: 0 5px;
                    margin-left: 10px;
                ">√ó</button>
            `;
            
            // Add CSS animation if not already present
            if (!document.querySelector('#api-notice-styles')) {
                const style = document.createElement('style');
                style.id = 'api-notice-styles';
                style.textContent = `
                    @keyframes slideDown {
                        from { opacity: 0; transform: translateY(-10px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            header.appendChild(notice);
            
            // Auto-remove after 10 seconds for warnings (not errors)
            if (type === 'warning') {
                setTimeout(() => {
                    if (notice.parentElement) {
                        notice.remove();
                    }
                }, 10000);
            }
        }

        // Add logout button to header
        document.addEventListener('DOMContentLoaded', function() {
            const header = document.querySelector('.header');
            const userEmail = localStorage.getItem('ventilation_user_email') || 'User';
            
            const userSection = document.createElement('div');
            userSection.style.cssText = 'position: absolute; top: 15px; right: 20px; font-size: 0.9em;';
            userSection.innerHTML = `
                <span style="margin-right: 15px;">Welcome, ${userEmail}</span>
                <button onclick="logout()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">Logout</button>
            `;
            
            header.style.position = 'relative';
            header.appendChild(userSection);
            
            // Add no-data notice if no authentication is provided
            const token = localStorage.getItem('ventilation_auth_token');
            if (!CONFIG.apiSecret && !token) {
                const noDataNotice = document.createElement('div');
                noDataNotice.style.cssText = 'background: rgba(255,193,7,0.9); color: #212529; padding: 10px; text-align: center; font-size: 0.9em; border-radius: 5px; margin-top: 10px;';
                noDataNotice.innerHTML = 'üìä <strong>No Data Available:</strong> Data is currently unavailable. <a href="login.html" style="color: #0056b3; text-decoration: underline;">Log in</a> or add <code>?apikey=VentilationSystem2025SecretKey</code> to URL for live data.';
                header.appendChild(noDataNotice);
            }
            
            initializeDashboard();
        });

        // Initialize dashboard
        async function initializeDashboard() {
            await refreshData();
            // Load default 6-hour chart
            await loadChart(6); // Load 6-hour chart by default
            
            // Start auto-refresh
            startAutoRefresh();
        }

        async function refreshData() {
            try {
                updateConnectionStatus('connecting');
                
                const token = localStorage.getItem('ventilation_auth_token');
                
                // If no authentication method is available, show no data
                if (!token && !CONFIG.apiSecret) {
                    // No authentication available, show no data state
                    showNoDataState();
                    updateConnectionStatus('disconnected');
                    return;
                }
                
                const response = await fetch(`${CONFIG.statusApiUrl}?deviceId=${CONFIG.deviceId}`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (response.status === 401) {
                    // Only logout if using API key authentication
                    // For Bearer token, fall back to mock data until functions are updated
                    const token = localStorage.getItem('ventilation_auth_token');
                    if (!token && CONFIG.apiSecret) {
                        // Using API key and got 401 - logout
                        logout();
                        return;
                    } else if (token) {
                        // Using Bearer token but got 401 - functions may not support it yet
                        // Bearer token authentication failed, show no data state
                        showApiFailureNotice('Status API returned 401 Unauthorized. Please check authentication or contact system administrator.', 'error');
                        showNoDataState();
                        updateConnectionStatus('disconnected');
                        return;
                    }
                }
                
                if (!response.ok) {
                    // Log the error details for debugging
                    console.error(`API Error: ${response.status} ${response.statusText}`);
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    
                    // If unauthorized and no API secret, show no data
                    if (response.status === 401 || response.status === 404) {
                        // API call failed, show no data state
                        showApiFailureNotice(`Status API returned ${response.status} ${response.statusText}. Data is currently unavailable.`, 'error');
                        showNoDataState();
                        updateConnectionStatus('disconnected');
                        return;
                    }
                    showApiFailureNotice(`Status API returned ${response.status} ${response.statusText}. Data is currently unavailable.`, 'error');
                    showNoDataState();
                    updateConnectionStatus('disconnected');
                    return;
                }
                
                const data = await response.json();
                updateDashboard(data);
                updateConnectionStatus('connected');

                // Refresh chart data if chart is currently displayed
                refreshCurrentChart();
            } catch (error) {
                console.error('Error fetching data:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    token: localStorage.getItem('ventilation_auth_token') ? 'Present' : 'Missing',
                    apiSecret: CONFIG.apiSecret ? 'Present' : 'Missing'
                });
                
                // Show no data instead of mock data
                // Network error, show no data state
                showApiFailureNotice(`Network error connecting to Status API: ${error.message}. Data is currently unavailable.`, 'error');
                showNoDataState();
                updateConnectionStatus('disconnected');
            }
        }

        function showNoDataState() {
            // Hide loading, show content with no data message
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('dashboardContent').style.display = 'block';

            // Set all sensor readings to "No data"
            document.getElementById('indoorTemp').textContent = 'No data';
            document.getElementById('indoorHumidity').textContent = 'No data';
            document.getElementById('indoorPressure').textContent = 'No data';
            document.getElementById('outdoorTemp').textContent = 'No data';
            document.getElementById('outdoorHumidity').textContent = 'No data';
            document.getElementById('outdoorPressure').textContent = 'No data';
            document.getElementById('garageTemp').textContent = 'No data';
            document.getElementById('garageHumidity').textContent = 'No data';
            document.getElementById('garagePressure').textContent = 'No data';

            // Set system status to no data
            document.getElementById('fanStatus').textContent = '‚ùì';
            document.getElementById('fanStatus').className = 'fan-status';
            document.getElementById('fanStatusText').textContent = 'No data';
            document.getElementById('ventilationMode').textContent = 'No data';
            document.getElementById('fanMinutes').textContent = 'No data';
            document.getElementById('freshAirStatus').textContent = 'No data';
            document.getElementById('ventilationHours').textContent = 'No data';
            document.getElementById('coolingEffect').textContent = 'No data';

            // Set weather to no data
            document.getElementById('forecastHigh').textContent = 'No data';
            document.getElementById('stormRisk').textContent = 'No data';
            document.getElementById('stormRiskExplanation').textContent = 'Storm risk status will be explained here.';

            // Set system info to no data
            document.getElementById('uptime').textContent = 'No data';
            
            // Set reliability info to no data (only elements that still exist)
            document.getElementById('rebootCount').textContent = 'No data';
            document.getElementById('wifiOutageCount').textContent = 'No data';

            // Hide door section since no data
            document.getElementById('doorSection').style.display = 'none';

            // Update last update time
            document.getElementById('lastUpdate').textContent = 'No data available';
        }

        function updateDashboard(data) {
            // Hide loading, show content
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('dashboardContent').style.display = 'block';

            // Update sensors with proper null/undefined handling
            const sensors = data.sensors || {};
            const indoor = sensors.indoor || {};
            const outdoor = sensors.outdoor || {};
            const garage = sensors.garage || {};
            
            document.getElementById('indoorTemp').textContent = indoor.temp != null ? `${indoor.temp.toFixed(1)}¬∞F` : 'No data';
            document.getElementById('indoorHumidity').textContent = indoor.humidity != null ? `${indoor.humidity.toFixed(0)}%` : 'No data';
            document.getElementById('indoorPressure').textContent = indoor.pressure != null ? `${indoor.pressure.toFixed(2)} inHg` : 'No data';
            
            document.getElementById('outdoorTemp').textContent = outdoor.temp != null ? `${outdoor.temp.toFixed(1)}¬∞F` : 'No data';
            document.getElementById('outdoorHumidity').textContent = outdoor.humidity != null ? `${outdoor.humidity.toFixed(0)}%` : 'No data';
            document.getElementById('outdoorPressure').textContent = outdoor.pressure != null ? `${outdoor.pressure.toFixed(2)} inHg` : 'No data';
            
            document.getElementById('garageTemp').textContent = garage.temp != null ? `${garage.temp.toFixed(1)}¬∞F` : 'No data';
            document.getElementById('garageHumidity').textContent = garage.humidity != null ? `${garage.humidity.toFixed(0)}%` : 'No data';
            document.getElementById('garagePressure').textContent = garage.pressure != null ? `${garage.pressure.toFixed(2)} inHg` : 'No data';

            // Update system status with proper null/undefined handling
            const system = data.system || {};
            const fanOn = system.fanOn;
            
            if (fanOn != null) {
                document.getElementById('fanStatus').textContent = fanOn ? 'üåÄ' : '‚è∏Ô∏è';
                document.getElementById('fanStatus').className = `fan-status ${fanOn ? 'fan-on' : 'fan-off'}`;
                document.getElementById('fanStatusText').textContent = fanOn ? 'RUNNING' : 'STOPPED';
            } else {
                document.getElementById('fanStatus').textContent = '‚ùì';
                document.getElementById('fanStatus').className = 'fan-status';
                document.getElementById('fanStatusText').textContent = 'No data';
            }
            
            document.getElementById('ventilationMode').textContent = system.ventilationMode || 'No data';
            document.getElementById('fanMinutes').textContent = system.fanMinutesToday != null ? system.fanMinutesToday : 'No data';
            document.getElementById('freshAirStatus').textContent = system.freshAirActive != null ? (system.freshAirActive ? 'Active' : 'Inactive') : 'No data';
            document.getElementById('ventilationHours').textContent = system.operatingHours || 'No data';
            
            // Calculate and display cooling effect
            const coolingEffect = calculateCoolingEffect(
                indoor.temp, 
                outdoor.temp, 
                system.fanMinutesToday, 
                fanOn
            );
            document.getElementById('coolingEffect').textContent = coolingEffect;

            // Update weather with proper null/undefined handling
            const weather = data.weather || {};
            const stormRiskValue = weather.stormRisk || 'No data';
            document.getElementById('forecastHigh').textContent = weather.forecastHigh != null ? `${weather.forecastHigh.toFixed(0)}¬∞F` : 'No data';
            document.getElementById('stormRisk').textContent = stormRiskValue;
            
            // Update storm risk explanation based on the actual value
            const stormRiskExplanation = document.getElementById('stormRiskExplanation');
            if (stormRiskValue && stormRiskValue !== 'No data') {
                const explanations = {
                    'Clear': 'Stable pressure - no significant changes over 3 hours.',
                    'Possible': 'Low pressure below 1000 hPa detected.',
                    'Likely': 'Pressure drop >3 hPa over 3 hours detected.',
                    'Imminent': 'Rapid pressure drop >5 hPa over 3 hours detected!'
                };
                stormRiskExplanation.textContent = explanations[stormRiskValue] || `${stormRiskValue} - pressure trend indicates weather change.`;
            } else {
                stormRiskExplanation.textContent = 'Storm risk status will be explained here.';
            }
            
            // Update system info with proper null/undefined handling
            const uptimeHours = system.uptime != null ? Math.floor(system.uptime / 3600) : null;
            document.getElementById('uptime').textContent = uptimeHours != null ? `${uptimeHours}h` : 'No data';

            // Update reliability statistics with proper null/undefined handling (only elements that still exist)
            const reliability = data.reliability || {};
            document.getElementById('rebootCount').textContent = reliability.rebootCount != null ? reliability.rebootCount : 'No data';
            document.getElementById('wifiOutageCount').textContent = reliability.wifiOutageCount != null ? reliability.wifiOutageCount : 'No data';

            // Update incidents if available
            if (data.incidents) {
                updateIncidents(data.incidents);
            }

            // Update doors if available
            if (data.doors && data.doors.length > 0) {
                updateDoorStatus(data.doors);
            }

            // Check for alerts
            checkAlerts(data);

            // Update last update time
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        function updateDoorStatus(doors) {
            const doorSection = document.getElementById('doorSection');
            const doorList = document.getElementById('doorList');
            
            if (doors.length === 0) {
                doorSection.style.display = 'none';
                return;
            }

            doorSection.style.display = 'block';
            doorList.innerHTML = '';

            doors.forEach(door => {
                const doorItem = document.createElement('div');
                doorItem.className = 'door-item';
                doorItem.style.cssText = `
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    padding: 15px;
                    margin-bottom: 10px;
                    background: ${door.open ? '#fff5f5' : '#f8fff8'};
                    border-color: ${door.open ? '#ffcccb' : '#ccffcc'};
                `;
                
                // Format timestamps
                const formatTime = (timestamp) => {
                    if (!timestamp || timestamp === '0') return 'N/A';
                    const date = new Date(parseInt(timestamp) * 1000);
                    const now = new Date();
                    const isToday = date.toDateString() === now.toDateString();
                    
                    if (isToday) {
                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    } else {
                        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                };
                
                const formatDuration = (minutes) => {
                    if (minutes < 60) return `${minutes}m`;
                    const hours = Math.floor(minutes / 60);
                    const mins = minutes % 60;
                    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                };
                
                // Door name and current status
                let statusHtml = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="font-size: 1.1em;">${door.name || `Door ${door.id}`}</strong>
                        <span class="sensor-value ${door.open ? 'fan-on' : 'fan-off'}" style="font-size: 1.2em;">
                            ${door.open ? 'üîì OPEN' : 'üîí CLOSED'}
                        </span>
                    </div>
                `;
                
                // Current session info
                if (door.open) {
                    statusHtml += `
                        <div class="door-detail">
                            <strong>Current Session:</strong>
                            <div style="margin-left: 15px;">
                                ‚Ä¢ Opened at: ${formatTime(door.openedAt)}<br>
                                ‚Ä¢ Duration: ${formatDuration(door.minutesOpen || 0)}
                            </div>
                        </div>
                    `;
                }
                
                // Daily summary
                if (door.wasOpenedToday) {
                    statusHtml += `
                        <div class="door-detail" style="margin-top: 10px;">
                            <strong>Today's Activity:</strong>
                            <div style="margin-left: 15px;">
                                ‚Ä¢ Total time open: ${formatDuration(door.minutesTotalToday || 0)}<br>
                                ‚Ä¢ First opened: ${formatTime(door.firstOpenedToday)}<br>
                                ‚Ä¢ Last opened: ${formatTime(door.lastOpenedToday)}
                            </div>
                        </div>
                    `;
                } else {
                    statusHtml += `
                        <div class="door-detail" style="margin-top: 10px; color: #666;">
                            <strong>Today's Activity:</strong> Not opened today
                        </div>
                    `;
                }
                
                doorItem.innerHTML = statusHtml;
                doorList.appendChild(doorItem);
            });
        }

        function updateIncidents(incidents) {
            const incidentsList = document.getElementById('incidentsList');
            const incidentsSummary = document.getElementById('incidentsSummary');
            
            if (!incidents || incidents.length === 0) {
                incidentsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No incidents recorded in the last 30 days</div>';
                incidentsSummary.innerHTML = '<strong>All systems operating normally</strong> - No incidents detected';
                return;
            }

            // Sort incidents by start time (newest first)
            const sortedIncidents = incidents.sort((a, b) => b.startTime - a.startTime);
            
            // Define incident type names and icons
            const incidentTypes = {
                0: { name: 'Power Loss', icon: '‚ö°' },
                1: { name: 'WiFi Down', icon: 'üì∂' },
                2: { name: 'Internet Down', icon: 'üåê' },
                3: { name: 'API Down', icon: '‚òÅÔ∏è' },
                4: { name: 'Storm Event', icon: 'üå©Ô∏è' },
                5: { name: 'Heat Event', icon: 'üî•' },
                6: { name: 'Freeze Event', icon: 'üßä' }
            };
            
            const severityNames = ['Critical', 'High', 'Medium', 'Low'];
            const severityClasses = ['incident-critical', 'incident-high', 'incident-medium', 'incident-low'];
            
            // Build incidents HTML
            let incidentsHtml = '';
            for (const incident of sortedIncidents.slice(0, 10)) { // Show last 10 incidents
                const typeInfo = incidentTypes[incident.type] || { name: 'Unknown', icon: '‚ùì' };
                const severity = severityNames[incident.severity] || 'Unknown';
                const severityClass = severityClasses[incident.severity] || 'incident-low';
                
                const startTime = new Date(incident.startTime * 1000);
                const endTime = incident.endTime > 0 ? new Date(incident.endTime * 1000) : null;
                
                const formatDateTime = (date) => {
                    const now = new Date();
                    const isToday = date.toDateString() === now.toDateString();
                    const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                    const isYesterday = date.toDateString() === yesterday.toDateString();
                    
                    const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    
                    if (isToday) return `Today ${timeStr}`;
                    if (isYesterday) return `Yesterday ${timeStr}`;
                    return `${date.toLocaleDateString()} ${timeStr}`;
                };
                
                const formatDuration = (seconds) => {
                    if (seconds < 60) return `${seconds}s`;
                    const minutes = Math.floor(seconds / 60);
                    if (minutes < 60) return `${minutes}m`;
                    const hours = Math.floor(minutes / 60);
                    const remainingMinutes = minutes % 60;
                    return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
                };
                
                const duration = incident.endTime > 0 ? 
                    formatDuration(incident.duration) : 
                    'Ongoing';
                
                const timeRange = endTime ? 
                    `${formatDateTime(startTime)} - ${formatDateTime(endTime)}` :
                    `${formatDateTime(startTime)} (ongoing)`;
                
                incidentsHtml += `
                    <div class="incident-item ${severityClass}">
                        <div class="incident-header">
                            ${typeInfo.icon} ${severity} ${typeInfo.name}
                        </div>
                        <div class="incident-details">
                            ${timeRange} (${duration})
                        </div>
                    </div>
                `;
            }
            
            incidentsList.innerHTML = incidentsHtml;
            
            // Build summary
            const totalIncidents = incidents.length;
            const severityCounts = [0, 0, 0, 0];
            incidents.forEach(incident => {
                if (incident.severity >= 0 && incident.severity <= 3) {
                    severityCounts[incident.severity]++;
                }
            });
            
            const summaryParts = [];
            if (totalIncidents === 1) {
                summaryParts.push('1 incident');
            } else {
                summaryParts.push(`${totalIncidents} incidents`);
            }
            
            if (severityCounts[0] > 0) summaryParts.push(`${severityCounts[0]} Critical`);
            if (severityCounts[1] > 0) summaryParts.push(`${severityCounts[1]} High`);
            if (severityCounts[2] > 0) summaryParts.push(`${severityCounts[2]} Medium`);
            if (severityCounts[3] > 0) summaryParts.push(`${severityCounts[3]} Low`);
            
            incidentsSummary.innerHTML = `<strong>Last 30 days:</strong> ${summaryParts.join(' | ')}`;
        }

        function checkAlerts(data) {
            const alerts = [];
            const sensors = data.sensors || {};
            const system = data.system || {};
            const weather = data.weather || {};

            // Temperature alerts
            const indoorTemp = sensors.indoor?.temp || 0;
            if (indoorTemp > 85) {
                alerts.push({type: 'danger', message: `High indoor temperature: ${indoorTemp.toFixed(1)}¬∞F`});
            } else if (indoorTemp < 60) {
                alerts.push({type: 'warning', message: `Low indoor temperature: ${indoorTemp.toFixed(1)}¬∞F`});
            }

            const garageTemp = sensors.garage?.temp || 0;
            if (garageTemp > 95) {
                alerts.push({type: 'danger', message: `High garage temperature: ${garageTemp.toFixed(1)}¬∞F`});
            } else if (garageTemp < 35) {
                alerts.push({type: 'warning', message: `Low garage temperature: ${garageTemp.toFixed(1)}¬∞F`});
            }

            // System alerts
            const freeHeap = system.freeHeap || 0;
            if (freeHeap < 50000) {
                alerts.push({type: 'warning', message: `Low memory: ${Math.round(freeHeap/1024)}KB available`});
            }

            // Storm alerts
            const stormRisk = weather.stormRisk || 'NONE';
            if (stormRisk === 'STORM_LIKELY' || stormRisk === 'STORM_IMMINENT') {
                alerts.push({type: 'warning', message: `Weather alert: ${stormRisk.replace('_', ' ')}`});
            }

            // Door alerts
            if (data.doors) {
                data.doors.forEach(door => {
                    if (door.open && door.minutesOpen > 240) { // 4 hours
                        alerts.push({type: 'warning', message: `${door.name || 'Door'} open for ${door.minutesOpen} minutes`});
                    }
                });
            }

            updateAlerts(alerts);
        }

        function updateAlerts(alerts) {
            const alertSection = document.getElementById('alertSection');
            const alertList = document.getElementById('alertList');

            if (alerts.length === 0) {
                alertSection.style.display = 'none';
                return;
            }

            alertSection.style.display = 'block';
            alertList.innerHTML = '';

            alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${alert.type}`;
                alertDiv.textContent = alert.message;
                alertList.appendChild(alertDiv);
            });
        }

        async function loadChart(hours) {
            // Track the current chart time period
            currentChartHours = hours;            // Update active button - find the button with matching hours
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.remove('active');
                // Check if this button's onclick matches the requested hours
                const onclick = btn.getAttribute('onclick');
                if (onclick && onclick.includes(`loadChart(${hours})`)) {
                    btn.classList.add('active');
                }
            });

            try {
                const token = localStorage.getItem('ventilation_auth_token');
                
                // If no authentication method is available, show empty chart
                if (!token && !CONFIG.apiSecret) {
                    // No authentication available, show empty chart
                    updateChart([], hours);
                    return;
                }

                const response = await fetch(`${CONFIG.historyApiUrl}?deviceId=${CONFIG.deviceId}&hours=${hours}`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (response.status === 401) {
                    // Only logout if using API key authentication
                    // For Bearer token, fall back to mock data until functions are updated
                    const token = localStorage.getItem('ventilation_auth_token');
                    if (!token && CONFIG.apiSecret) {
                        // Using API key and got 401 - logout
                        logout();
                        return;
                    } else if (token) {
                        // Using Bearer token but got 401 - functions may not support it yet
                        // Bearer token chart authentication failed, show empty chart
                        showApiFailureNotice('History API returned 401 Unauthorized. Chart data is currently unavailable.', 'warning');
                        updateChart([], hours);
                        return;
                    }
                }
                
                if (!response.ok) {
                    // Show empty chart if API fails
                    // Chart API call failed, show empty chart
                    showApiFailureNotice(`History API returned ${response.status} ${response.statusText}. Chart data is currently unavailable.`, 'warning');
                    updateChart([], hours);
                    return;
                }
                
                const data = await response.json();
                if (data.data && data.data.length > 0) {
                    try {
                        const firstTimestamp = new Date(data.data[0].timestamp);
                        const lastTimestamp = new Date(data.data[data.data.length - 1].timestamp);
                        
                        // Check if timestamps are valid before trying to use them
                        if (!isNaN(firstTimestamp.getTime()) && !isNaN(lastTimestamp.getTime())) {
                            const apiSpanHours = (lastTimestamp.getTime() - firstTimestamp.getTime()) / (1000 * 60 * 60);
                            // API data span calculated for internal tracking
                        }
                    } catch (timestampError) {
                        // Error parsing timestamps for logging, proceeding with chart update
                    }
                }
                updateChart(data.data || [], hours);
                
            } catch (error) {
                console.error('Error loading chart data:', error);
                // Show empty chart instead of mock data
                showApiFailureNotice(`Network error loading chart data: ${error.message}. Chart data is currently unavailable.`, 'warning');
                updateChart([], hours);
            }
        }

        // Function to refresh the currently displayed chart without changing time period
        async function refreshCurrentChart() {
            if (temperatureChart) {
                // Check if there's new chart data before refreshing
                await checkAndRefreshChart(currentChartHours);
            }
        }

        // Smart chart refresh - only refreshes if new data is available
        async function checkAndRefreshChart(hours) {
            try {
                const token = localStorage.getItem('ventilation_auth_token');
                
                // If no authentication method is available, skip chart refresh
                if (!token && !CONFIG.apiSecret) {
                    return;
                }

                const response = await fetch(`${CONFIG.historyApiUrl}?deviceId=${CONFIG.deviceId}&hours=${hours}`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    // Don't refresh chart if API fails
                    return;
                }
                
                const data = await response.json();
                if (!data.data || data.data.length === 0) {
                    // No data available, don't refresh
                    return;
                }

                // Get the latest timestamp from the new data
                const latestDataPoint = data.data[0]; // API returns newest first
                let newLatestTimestamp = null;

                // Parse the timestamp from the latest data point
                if (latestDataPoint.timestamp) {
                    if (typeof latestDataPoint.timestamp === 'string') {
                        if (latestDataPoint.timestamp.includes('T') || latestDataPoint.timestamp.includes('-')) {
                            newLatestTimestamp = new Date(latestDataPoint.timestamp);
                        } else {
                            const unixSeconds = parseInt(latestDataPoint.timestamp);
                            if (!isNaN(unixSeconds) && unixSeconds > 1000000000) {
                                newLatestTimestamp = new Date(unixSeconds * 1000);
                            } else {
                                newLatestTimestamp = new Date(latestDataPoint.timestamp);
                            }
                        }
                    } else if (typeof latestDataPoint.timestamp === 'number') {
                        const timestamp = latestDataPoint.timestamp;
                        newLatestTimestamp = timestamp < 10000000000 ? new Date(timestamp * 1000) : new Date(timestamp);
                    } else {
                        newLatestTimestamp = new Date(latestDataPoint.timestamp);
                    }
                }

                // If we can't parse the timestamp, refresh anyway to be safe
                if (!newLatestTimestamp || isNaN(newLatestTimestamp.getTime())) {
                    console.log('Chart refresh: Unable to parse timestamp, refreshing anyway');
                    updateChart(data.data, hours);
                    return;
                }

                // Check if this is newer than our stored latest timestamp
                if (!latestChartDataTimestamp || newLatestTimestamp > latestChartDataTimestamp) {
                    console.log(`Chart refresh: New data available (${newLatestTimestamp.toLocaleTimeString()})`, {
                        previous: latestChartDataTimestamp ? latestChartDataTimestamp.toLocaleTimeString() : 'none',
                        new: newLatestTimestamp.toLocaleTimeString()
                    });
                    
                    // Update our stored timestamp and refresh the chart
                    latestChartDataTimestamp = newLatestTimestamp;
                    updateChart(data.data, hours);
                } else {
                    console.log('Chart refresh: No new data, skipping refresh', {
                        latest: latestChartDataTimestamp.toLocaleTimeString(),
                        checked: newLatestTimestamp.toLocaleTimeString()
                    });
                }

            } catch (error) {
                console.error('Error checking for new chart data:', error);
                // On error, don't refresh to avoid unnecessary animations
            }
        }

        function updateChart(data, requestedHours = 6) {
            const ctx = document.getElementById('temperatureChart').getContext('2d');
            
            // Update latest timestamp tracking for smart refresh
            if (data && data.length > 0) {
                const latestDataPoint = data[0]; // API returns newest first
                if (latestDataPoint.timestamp) {
                    let timestamp;
                    if (typeof latestDataPoint.timestamp === 'string') {
                        if (latestDataPoint.timestamp.includes('T') || latestDataPoint.timestamp.includes('-')) {
                            timestamp = new Date(latestDataPoint.timestamp);
                        } else {
                            const unixSeconds = parseInt(latestDataPoint.timestamp);
                            if (!isNaN(unixSeconds) && unixSeconds > 1000000000) {
                                timestamp = new Date(unixSeconds * 1000);
                            } else {
                                timestamp = new Date(latestDataPoint.timestamp);
                            }
                        }
                    } else if (typeof latestDataPoint.timestamp === 'number') {
                        const ts = latestDataPoint.timestamp;
                        timestamp = ts < 10000000000 ? new Date(ts * 1000) : new Date(ts);
                    } else {
                        timestamp = new Date(latestDataPoint.timestamp);
                    }
                    
                    if (!isNaN(timestamp.getTime())) {
                        latestChartDataTimestamp = timestamp;
                    }
                }
            }
            
            // Destroy existing chart
            if (temperatureChart) {
                temperatureChart.destroy();
            }

            // If no data, create a simple "no data" chart
            if (!data || data.length === 0) {
                temperatureChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No Data Available'],
                        datasets: [{
                            label: 'No Data',
                            data: [0],
                            borderColor: '#ddd',
                            backgroundColor: 'rgba(221, 221, 221, 0.1)',
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: {
                                    generateLabels: function() {
                                        return [{
                                            text: 'No data available - check authentication or API connection',
                                            fillStyle: '#ddd',
                                            strokeStyle: '#ddd'
                                        }];
                                    }
                                }
                            }
                        },
                        scales: {
                            y: { 
                                display: true,
                                title: { display: true, text: 'Waiting for data...' }
                            },
                            x: { 
                                display: true,
                                title: { display: true, text: 'Time' }
                            }
                        }
                    }
                });
                return;
            }
            
            // Data comes from API in reverse chronological order (newest first)
            // We need to reverse it to show oldest to newest (left to right)
            let sortedData = [...data].reverse();
            
            // Filter out corrupted data with invalid timestamps (fix for chart showing years 1954, 1963, 1972, 1981)
            function isValidTimestamp(timestamp) {
                let date;
                
                if (typeof timestamp === 'string') {
                    if (timestamp.includes('T') || timestamp.includes('-')) {
                        date = new Date(timestamp);
                    } else {
                        const unixSeconds = parseInt(timestamp);
                        if (!isNaN(unixSeconds) && unixSeconds > 1000000000 && unixSeconds < 2000000000) {
                            date = new Date(unixSeconds * 1000);
                        } else {
                            return false;
                        }
                    }
                } else if (typeof timestamp === 'number') {
                    if (timestamp < 1000000000 || timestamp > 2000000000) {
                        return false; // Invalid Unix timestamp range
                    }
                    date = timestamp < 10000000000 ? new Date(timestamp * 1000) : new Date(timestamp);
                } else {
                    return false;
                }
                
                // Reject timestamps before 2020 or after 2030 (likely corrupted)
                const year = date.getFullYear();
                return !isNaN(date.getTime()) && year >= 2020 && year <= 2030;
            }
            
            // Filter out items with corrupted timestamps
            sortedData = sortedData.filter(item => {
                if (!item.timestamp) return false;
                return isValidTimestamp(item.timestamp);
            });
            
            console.log(`Chart data: ${data.length} total items, ${sortedData.length} valid items after timestamp filtering`);
            
            // Debug: Log sample timestamps from the API
            if (data.length > 0) {
                console.log('Sample raw timestamps from API:', data.slice(0, 3).map(item => ({
                    timestamp: item.timestamp,
                    type: typeof item.timestamp
                })));
            }
            
            if (sortedData.length > 0) {
                console.log('Sample timestamps after filtering:', sortedData.slice(0, 3).map(item => item.timestamp));
            }
            
            // Prepare time-based data points for proper temporal spacing
            const timeBasedData = sortedData.map((item, index) => {
                let date;
                
                // Handle different timestamp formats with enhanced validation
                if (typeof item.timestamp === 'string') {
                    if (item.timestamp.includes('T') || item.timestamp.includes('-')) {
                        date = new Date(item.timestamp);
                    } else {
                        const unixSeconds = parseInt(item.timestamp);
                        if (!isNaN(unixSeconds) && unixSeconds > 1000000000 && unixSeconds < 2000000000) {
                            date = new Date(unixSeconds * 1000);
                        } else {
                            console.warn('Invalid Unix timestamp:', item.timestamp);
                            return null; // Skip this item
                        }
                    }
                } else if (typeof item.timestamp === 'number') {
                    if (item.timestamp < 1000000000 || item.timestamp > 2000000000) {
                        console.warn('Invalid numeric timestamp:', item.timestamp);
                        return null; // Skip this item
                    }
                    date = item.timestamp < 10000000000 ? new Date(item.timestamp * 1000) : new Date(item.timestamp);
                } else {
                    console.warn('Unknown timestamp format:', item.timestamp);
                    return null; // Skip this item
                }
                
                // Final validation - reject if date is invalid or outside reasonable range
                if (isNaN(date.getTime())) {
                    console.warn('Failed to parse timestamp:', item.timestamp);
                    return null;
                }
                
                const year = date.getFullYear();
                if (year < 2020 || year > 2030) {
                    console.warn('Timestamp outside valid range (corrupted):', date.toISOString(), 'from:', item.timestamp);
                    return null;
                }
                
                return {
                    timestamp: date,
                    item: item
                };
            }).filter(dataPoint => dataPoint !== null); // Remove null entries

            // Debug: Log the final timestamp range being sent to chart
            if (timeBasedData.length > 0) {
                const timestamps = timeBasedData.map(d => d.timestamp);
                const minTime = new Date(Math.min(...timestamps));
                const maxTime = new Date(Math.max(...timestamps));
                console.log('Chart timestamp range:', {
                    earliest: minTime.toISOString(),
                    latest: maxTime.toISOString(),
                    span: `${((maxTime - minTime) / (1000 * 60 * 60)).toFixed(1)} hours`,
                    count: timeBasedData.length
                });
            }

            // Extract the actual sensor data with timestamps for Chart.js time scale
            const indoorTemps = timeBasedData.map(dataPoint => {
                // Check if the item has the expected structure
                if (dataPoint.item.sensors && dataPoint.item.sensors.indoor && typeof dataPoint.item.sensors.indoor.temp === 'number') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.sensors.indoor.temp
                    };
                }
                return null;
            }).filter(point => point !== null);
            
            const outdoorTemps = timeBasedData.map(dataPoint => {
                if (dataPoint.item.sensors && dataPoint.item.sensors.outdoor && typeof dataPoint.item.sensors.outdoor.temp === 'number') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.sensors.outdoor.temp
                    };
                }
                return null;
            }).filter(point => point !== null);
            
            const garageTemps = timeBasedData.map(dataPoint => {
                if (dataPoint.item.sensors && dataPoint.item.sensors.garage && typeof dataPoint.item.sensors.garage.temp === 'number') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.sensors.garage.temp
                    };
                }
                return null;
            }).filter(point => point !== null);
            
            const fanStatus = timeBasedData.map(dataPoint => {
                if (dataPoint.item.system && typeof dataPoint.item.system.fanOn === 'boolean') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.system.fanOn ? 1 : 0
                    };
                }
                return null;
            }).filter(point => point !== null);

            // Debug fan status data
            console.log('Fan status data points:', fanStatus.length);
            if (fanStatus.length > 0) {
                console.log('Sample fan status data:', fanStatus.slice(0, 3));
            }

            // Create new chart with time-based data
            temperatureChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Indoor Temperature (¬∞F)',
                            data: indoorTemps,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            tension: 0.4,
                            yAxisID: 'temp'
                        },
                        {
                            label: 'Outdoor Temperature (¬∞F)',
                            data: outdoorTemps,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.4,
                            yAxisID: 'temp'
                        },
                        {
                            label: 'Garage Temperature (¬∞F)',
                            data: garageTemps,
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            tension: 0.4,
                            yAxisID: 'temp'
                        },
                        {
                            label: 'Fan Status',
                            data: fanStatus,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.2)',
                            stepped: true,
                            fill: true,
                            tension: 0,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            yAxisID: 'fan'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        temp: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (¬∞F)'
                            }
                        },
                        fan: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 1,
                            title: {
                                display: true,
                                text: 'Fan Status'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value === 1 ? 'ON' : 'OFF';
                                }
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    minute: 'h:mm a',
                                    hour: 'h a',
                                    day: 'M/d'
                                },
                                tooltipFormat: 'MMM d, h:mm a'
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                maxRotation: 45,
                                minRotation: 0,
                                autoSkip: true
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        function updateConnectionStatus(status) {
            const indicator = document.getElementById('connectionStatus');
            const text = document.getElementById('connectionText');

            switch(status) {
                case 'connected':
                    indicator.className = 'status-indicator online';
                    text.textContent = 'Connected';
                    break;
                case 'connecting':
                    indicator.className = 'status-indicator';
                    text.textContent = 'Connecting...';
                    break;
                case 'error':
                    indicator.className = 'status-indicator';
                    text.textContent = 'Connection Error';
                    break;
            }
        }

        function showError() {
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('dashboardContent').style.display = 'none';
            document.getElementById('errorSection').style.display = 'block';
        }

        function startAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
            }
            
            refreshTimer = setInterval(async () => {
                await refreshData();
            }, CONFIG.refreshInterval);
        }

        // Manual refresh function
        window.refreshData = refreshData;

        // Cooling effect calculation function
        function calculateCoolingEffect(indoorTemp, outdoorTemp, fanMinutes, fanCurrentlyOn) {
            // Return "No data" if we don't have the required temperatures
            if (indoorTemp == null || outdoorTemp == null || fanMinutes == null) {
                return 'No data';
            }

            // If fan hasn't run today, show that
            if (fanMinutes === 0) {
                return fanCurrentlyOn ? 'Starting...' : 'Not used today';
            }

            // Constants for 4500 CFM fan system
            const FAN_CFM = 4500; // Cubic feet per minute
            const AIR_DENSITY = 0.075; // lbs per cubic foot at standard conditions
            const SPECIFIC_HEAT_AIR = 0.24; // BTU per lb per ¬∞F
            const MINUTES_PER_HOUR = 60;

            // Calculate temperature difference (how much cooling potential exists)
            const tempDiff = indoorTemp - outdoorTemp;
            
            // If outdoor is warmer than indoor, show day's performance instead of "No cooling benefit"
            if (tempDiff <= 0) {
                if (fanCurrentlyOn) {
                    return 'Warming air';
                } else {
                    // Calculate and show today's comprehensive performance summary
                    const fanHours = (fanMinutes / 60).toFixed(1);
                    const dutyCycle = ((fanMinutes / (24 * 60)) * 100).toFixed(1);
                    
                    // More realistic BTU and temperature impact calculation
                    // Use conservative 2¬∞F average beneficial temperature difference
                    const avgBeneficialTempDiff = 2.0;
                    const airMassFlowRate = FAN_CFM * AIR_DENSITY;
                    const avgHeatTransferRate = airMassFlowRate * SPECIFIC_HEAT_AIR * avgBeneficialTempDiff * MINUTES_PER_HOUR;
                    const totalBTUsTransferred = avgHeatTransferRate * fanHours;
                    const btuDisplay = totalBTUsTransferred >= 1000 ? 
                        `${(totalBTUsTransferred / 1000).toFixed(1)}k BTU` : 
                        `${totalBTUsTransferred.toFixed(0)} BTU`;
                    
                    // Realistic net temperature impact accounting for heat gain
                    // During daytime operation, house gains heat from:
                    // - Solar gain: ~5-15¬∞F potential rise
                    // - Appliances: ~1-3¬∞F potential rise  
                    // - Thermal mass: Variable impact
                    const HOUSE_VOLUME_CF = 25000;
                    const houseAirMass = HOUSE_VOLUME_CF * AIR_DENSITY;
                    
                    // Calculate gross cooling potential
                    const grossCoolingPotential = totalBTUsTransferred / (houseAirMass * SPECIFIC_HEAT_AIR);
                    
                    // Apply realistic efficiency factors for net cooling achieved:
                    // - Air mixing efficiency: 50% (not perfect circulation)
                    // - Heat gain offset during operation: 80% (major reduction in cooling effectiveness)
                    // - Thermal mass absorption: 70% (walls/furniture absorb some cooling)
                    const netCoolingAchieved = grossCoolingPotential * 0.5 * 0.2 * 0.7; // ~7% net efficiency
                    
                    return `${fanHours}h runtime (${dutyCycle}% duty) ‚Ä¢ ~${btuDisplay} transferred ‚Ä¢ ~${netCoolingAchieved.toFixed(1)}¬∞F net cooling achieved`;
                }
            }

            // Calculate heat transfer rate (BTU/hr) when fan is running
            const airMassFlowRate = FAN_CFM * AIR_DENSITY; // lbs/min
            const heatTransferRate = airMassFlowRate * SPECIFIC_HEAT_AIR * tempDiff * MINUTES_PER_HOUR; // BTU/hr

            // Estimate HOURLY cooling rate (more realistic)
            // House volume ~25,000 cubic feet (including high ceilings)
            const HOUSE_VOLUME_CF = 25000;
            const houseAirMass = HOUSE_VOLUME_CF * AIR_DENSITY; // lbs of air in house
            
            // Calculate theoretical temperature drop per hour of continuous operation
            // This assumes perfect mixing and no heat gain during operation
            const hourlyTempDropPotential = heatTransferRate / (houseAirMass * SPECIFIC_HEAT_AIR); // ¬∞F/hr
            
            // Apply realistic efficiency factors:
            // - Air mixing efficiency: ~60% (not perfect mixing)
            // - Heat gain offset: ~40% (sun, appliances, thermal mass warming)
            const MIXING_EFFICIENCY = 0.6;
            const HEAT_GAIN_FACTOR = 0.4; // Reduces effective cooling
            
            const practicalHourlyRate = hourlyTempDropPotential * MIXING_EFFICIENCY * (1 - HEAT_GAIN_FACTOR);
            
            // Calculate average cooling rate based on actual usage pattern
            // If fan runs 50% of the time, effective rate is halved
            const operatingEfficiency = Math.min(fanMinutes / (60 * 16), 1.0); // Assume 16-hour operating window
            const effectiveHourlyRate = practicalHourlyRate * operatingEfficiency;

            // Format the results
            const heatTransferKBTU = (heatTransferRate / 1000).toFixed(1); // Convert to thousands of BTU/hr
            const hourlyRate = Math.min(effectiveHourlyRate, tempDiff * 0.5).toFixed(1); // Cap at 50% of temp difference

            // Create status message based on current state
            let status = '';
            if (fanCurrentlyOn) {
                status = ` (${heatTransferKBTU}k BTU/hr)`;
            } else {
                // Show comprehensive daily performance summary when fan is off
                const fanHours = (fanMinutes / 60).toFixed(1);
                const totalCooling = (effectiveHourlyRate * (fanMinutes / 60)).toFixed(1);
                
                // Calculate total BTUs transferred during operation
                const totalBTUsTransferred = heatTransferRate * (fanMinutes / 60);
                const btuDisplay = totalBTUsTransferred >= 1000 ? 
                    `${(totalBTUsTransferred / 1000).toFixed(1)}k BTU` : 
                    `${totalBTUsTransferred.toFixed(0)} BTU`;
                
                // Calculate current potential if fan were running now
                const currentPotentialBTU = (heatTransferRate / 1000).toFixed(1);
                
                status = ` (${fanHours}h today ‚Ä¢ ${btuDisplay} transferred ‚Ä¢ ${totalCooling}¬∞F achieved ‚Ä¢ ${currentPotentialBTU}k BTU/hr potential)`;
            }

            return `~${hourlyRate}¬∞F/hr rate${status}`;
        }
    </script>

    <!-- Discrete Build Info Footer -->
    <div style="position: fixed; bottom: 5px; right: 10px; font-size: 12px; color: #555; font-family: monospace; z-index: 1000; background: rgba(255,255,255,0.8); padding: 2px 6px; border-radius: 3px;">
        Build: <span id="buildInfo">2025.07.29-1600-garage-data-display</span>
    </div>
</body>
</html>
