<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Ventilation Control Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script>
        // Authentication check - redirect to login if not authenticated
        window.addEventListener('load', function() {
            const token = localStorage.getItem('ventilation_auth_token');
            const apiKey = getApiKeyFromUrl();
            
            // If no token and no API key, show no data message (don't redirect)
            // This allows users to see the dashboard structure before logging in
            if (!token && !apiKey) {
                // Show no data state without authentication
                return;
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .subtitle {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }

        .status-indicator.online {
            background: #28a745;
        }

        .refresh-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .refresh-btn:hover {
            background: #0056b3;
        }

        .main-content {
            padding: 30px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }

        .card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .sensor-reading {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .sensor-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #2c3e50;
        }

        .temperature {
            color: #e74c3c;
        }

        .humidity {
            color: #3498db;
        }

        .pressure {
            color: #9b59b6;
        }

        .system-status {
            text-align: center;
            padding: 20px;
        }

        .fan-status {
            font-size: 3em;
            margin: 20px 0;
        }

        .fan-on {
            color: #28a745;
        }

        .fan-off {
            color: #dc3545;
        }

        .door-item {
            font-size: 0.95em;
        }

        .door-detail {
            margin: 8px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .door-detail strong {
            color: #2c3e50;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }

        .time-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .time-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .time-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .time-btn:hover {
            background: #e9ecef;
        }

        .time-btn.active:hover {
            background: #0056b3;
        }

        .alert-section {
            margin-top: 30px;
        }

        .alert {
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-danger {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .incident-item {
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .incident-critical {
            background: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }

        .incident-high {
            background: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }

        .incident-medium {
            background: #cce7ff;
            border-left-color: #007bff;
            color: #004085;
        }

        .incident-low {
            background: #f8f9fa;
            border-left-color: #6c757d;
            color: #495057;
        }

        .incident-header {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .incident-details {
            font-size: 0.85em;
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        .error {
            text-align: center;
            padding: 50px;
            color: #dc3545;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                align-items: stretch;
            }
            
            .time-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- test edit -->
    <div class="container">
        <div class="header">
            <h1>üåÄ ESP32 Ventilation Control</h1>
            <p class="subtitle">Real-time Environmental Monitoring & Control Dashboard</p>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="connectionStatus"></div>
                <span id="connectionText">Connecting...</span>
            </div>
            <div class="status-item">
                <span>Last Update: <span id="lastUpdate">-</span></span>
            </div>
            <button class="refresh-btn" onclick="refreshData()">üîÑ Refresh</button>
        </div>

        <div class="main-content">
            <div id="loadingSection" class="loading">
                <h3>Loading ventilation data...</h3>
                <p>Please wait while we fetch the latest information.</p>
            </div>

            <div id="errorSection" class="error" style="display: none;">
                <h3>‚ö†Ô∏è Connection Error</h3>
                <p>Unable to connect to the ventilation system. Please check your API endpoints.</p>
                <button class="refresh-btn" onclick="refreshData()">Try Again</button>
            </div>

            <div id="dashboardContent" style="display: none;">
                <!-- Current Status Grid -->
                <div class="grid">
                    <!-- Indoor Sensors -->
                    <div class="card">
                        <h3>üè† Indoor Environment</h3>
                        <div class="sensor-reading">
                            <span>Temperature</span>
                            <span class="sensor-value temperature" id="indoorTemp">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Humidity</span>
                            <span class="sensor-value humidity" id="indoorHumidity">-%</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Pressure</span>
                            <span class="sensor-value pressure" id="indoorPressure">- inHg</span>
                        </div>
                    </div>

                    <!-- Outdoor Sensors -->
                    <div class="card">
                        <h3>üå§Ô∏è Outdoor Environment</h3>
                        <div class="sensor-reading">
                            <span>Temperature</span>
                            <span class="sensor-value temperature" id="outdoorTemp">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Humidity</span>
                            <span class="sensor-value humidity" id="outdoorHumidity">-%</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Pressure</span>
                            <span class="sensor-value pressure" id="outdoorPressure">- inHg</span>
                        </div>
                    </div>

                    <!-- Garage Sensors -->
                    <div class="card">
                        <h3>üè† Garage Environment</h3>
                        <div class="sensor-reading">
                            <span>Temperature</span>
                            <span class="sensor-value temperature" id="garageTemp">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Humidity</span>
                            <span class="sensor-value humidity" id="garageHumidity">-%</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Pressure</span>
                            <span class="sensor-value pressure" id="garagePressure">- inHg</span>
                        </div>
                    </div>

                    <!-- System Status -->
                    <div class="card">
                        <h3>‚öôÔ∏è System Status</h3>
                        <div class="system-status">
                            <div class="fan-status" id="fanStatus">üåÄ</div>
                            <div><strong id="fanStatusText">System Status</strong></div>
                            <div style="margin-top: 15px;">
                                <div>Mode: <strong id="ventilationMode">-</strong></div>
                                <div>Runtime Today: <strong id="fanMinutes">0</strong> minutes</div>
                                <div>Fresh Air: <strong id="freshAirStatus">-</strong></div>
                                <div>Operating Hours: <strong id="ventilationHours">-</strong></div>
                                <div>Cooling Effect: <strong id="coolingEffect">-</strong></div>
                            </div>
                        </div>
                    </div>

                    <!-- Weather & Forecast -->
                    <div class="card">
                        <h3>üìä Weather & Forecast</h3>
                        <div class="sensor-reading">
                            <span>Forecast High</span>
                            <span class="sensor-value temperature" id="forecastHigh">-¬∞F</span>
                        </div>
                        <div class="sensor-reading">
                            <span>Storm Risk</span>
                            <span class="sensor-value" id="stormRisk">-</span>
                        </div>
                        <div id="stormRiskExplanation" style="font-size: 12px; color: #666; margin-top: 10px; font-style: italic;">
                            Storm risk status will be explained here.
                        </div>
                    </div>
                </div>

                <!-- Historical Charts -->
                <div class="card">
                    <h3>üìà Historical Data</h3>
                    <div class="time-controls">
                        <button class="time-btn active" onclick="loadChart(6)">6 Hours</button>
                        <button class="time-btn" onclick="loadChart(24)">24 Hours</button>
                        <button class="time-btn" onclick="loadChart(72)">3 Days</button>
                        <button class="time-btn" onclick="loadChart(168)">1 Week</button>
                    </div>
                    <div class="chart-container">
                        <canvas id="temperatureChart"></canvas>
                    </div>
                </div>

                <!-- Door Status -->
                <div class="card" id="doorSection" style="display: none;">
                    <h3>üö™ Door Status & Activity</h3>
                    <div id="doorList"></div>
                </div>

                <!-- Incident Trends Chart -->
                <div class="card">
                    <h3>üìä Incident Almanac</h3>
                    <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; border: 1px solid #ddd;">
                        <label style="font-weight: bold; margin-right: 10px; color: #333;">View:</label>
                        <select id="trendsViewFilter" onchange="loadIncidentTrends()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; background: white; margin-right: 15px;">
                            <option value="weekly">Weekly View</option>
                            <option value="monthly" selected>Monthly Summary</option>
                        </select>
                        
                        <label style="font-weight: bold; margin-right: 10px; color: #333;">Severity:</label>
                        <select id="trendsSeverityFilter" onchange="loadIncidentTrends()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; background: white;">
                            <option value="critical-high" selected>Critical & High</option>
                            <option value="critical">Critical Only</option>
                            <option value="high">High Only</option>
                            <option value="critical-high-medium">Critical, High & Medium</option>
                            <option value="all">All Severities (Critical, High, Medium, Low)</option>
                            <option value="medium">Medium Only</option>
                            <option value="low">Low Only</option>
                        </select>
                        <span id="trendsStatus" style="margin-left: 10px; font-size: 0.85em; color: #666;"></span>
                    </div>
                    <div class="chart-container" style="height: 400px;">
                        <canvas id="incidentTrendsChart"></canvas>
                    </div>
                </div>

                    <!-- System Incidents -->
                <div class="card">
                    <h3>üîß System Incidents</h3>
                    
                    <!-- Time Period Filter -->
                    <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; border: 1px solid #ddd;">
                        <label style="font-weight: bold; margin-right: 10px; color: #333;">Time Period:</label>
                        <select id="timePeriodFilter" onchange="applyIncidentFilters()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; background: white; margin-right: 15px;">
                            <option value="1">Last 24 Hours</option>
                            <option value="7" selected>Last Week</option>
                            <option value="30">Last 30 Days</option>
                        </select>
                        
                        <label style="font-weight: bold; margin-right: 10px; color: #333;">Severity:</label>
                        <select id="severityFilter" onchange="applyIncidentFilters()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; background: white;">
                            <option value="all">All Incidents</option>
                            <option value="0">Critical Only</option>
                            <option value="1">High and Above</option>
                            <option value="2">Medium and Above</option>
                            <option value="3">Low and Above (All)</option>
                        </select>
                        <span id="filterStatus" style="margin-left: 10px; font-size: 0.85em; color: #666;"></span>
                    </div>
                    
                    <!-- System Overview -->
                    <div style="margin-bottom: 15px; padding: 10px; background: #f0f8ff; border-radius: 5px; font-size: 0.9em; color: #444; border-left: 4px solid #007bff;">
                        <strong>System Overview:</strong> 
                        Uptime: <span id="uptime">-</span> | 
                        Total Reboots: <span id="rebootCount">-</span> | 
                        WiFi Outages: <span id="wifiOutageCount">-</span>
                    </div>
                    
                    <div id="incidentsList"></div>
                    <div id="incidentsSummary" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 0.9em; color: #666;">
                        Loading incident data...
                    </div>
                </div>

                <!-- Alerts -->
                <div class="alert-section" id="alertSection" style="display: none;">
                    <div class="card">
                        <h3>‚ö†Ô∏è System Alerts</h3>
                        <div id="alertList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration - Replace with your actual Azure Function URLs
        const CONFIG = {
            statusApiUrl: 'https://esp32-ventilation-api.azurewebsites.net/api/GetVentilationStatus',
            historyApiUrl: 'https://esp32-ventilation-api.azurewebsites.net/api/GetVentilationHistory',
            deviceId: 'ESP32-Ventilation-01',
            refreshInterval: 30000, // 30 seconds - check for new telemetry data
            apiSecret: getApiKeyFromUrl() || null // Get from URL parameter or environment
        };

        // Helper function to get API key from URL parameter
        function getApiKeyFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('apikey') || urlParams.get('key');
        }

        let temperatureChart = null;
        let incidentTrendsChart = null;
        let refreshTimer = null;
        let currentChartHours = 6; // Track the currently displayed time period
        let latestChartDataTimestamp = null; // Track the latest data point timestamp to avoid unnecessary chart refreshes

        // Authentication and API helper functions
        function getAuthHeaders() {
            const token = localStorage.getItem('ventilation_auth_token');
            const headers = {
                'Content-Type': 'application/json'
            };
            
            // If user is logged in, use Bearer token authentication
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            // Otherwise, use API key if available
            else if (CONFIG.apiSecret) {
                headers['X-API-Secret'] = CONFIG.apiSecret;
            }
            
            return headers;
        }

        function logout() {
            localStorage.removeItem('ventilation_auth_token');
            localStorage.removeItem('ventilation_user_email');
            window.location.href = 'login.html';
        }

        // Function to show API failure notifications
        function showApiFailureNotice(message, type = 'warning') {
            // Remove any existing notices
            const existingNotice = document.querySelector('.api-failure-notice');
            if (existingNotice) {
                existingNotice.remove();
            }

            const header = document.querySelector('.header');
            const notice = document.createElement('div');
            notice.className = 'api-failure-notice';
            notice.style.cssText = `
                background: ${type === 'error' ? 'rgba(220,53,69,0.9)' : 'rgba(255,193,7,0.9)'};
                color: ${type === 'error' ? 'white' : '#212529'};
                padding: 12px 15px;
                text-align: center;
                font-size: 0.9em;
                border-radius: 5px;
                margin-top: 15px;
                border: 1px solid ${type === 'error' ? 'rgba(220,53,69,0.5)' : 'rgba(255,193,7,0.5)'};
                animation: slideDown 0.3s ease-out;
            `;
            notice.innerHTML = `
                <strong>${type === 'error' ? '‚ö†Ô∏è API Error:' : '‚ö†Ô∏è Data Unavailable:'}</strong> ${message}
                <button onclick="this.parentElement.remove()" style="
                    float: right;
                    background: transparent;
                    border: none;
                    color: inherit;
                    font-size: 16px;
                    cursor: pointer;
                    padding: 0 5px;
                    margin-left: 10px;
                ">√ó</button>
            `;
            
            // Add CSS animation if not already present
            if (!document.querySelector('#api-notice-styles')) {
                const style = document.createElement('style');
                style.id = 'api-notice-styles';
                style.textContent = `
                    @keyframes slideDown {
                        from { opacity: 0; transform: translateY(-10px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            header.appendChild(notice);
            
            // Auto-remove after 10 seconds for warnings (not errors)
            if (type === 'warning') {
                setTimeout(() => {
                    if (notice.parentElement) {
                        notice.remove();
                    }
                }, 10000);
            }
        }

        // Add logout button to header
        document.addEventListener('DOMContentLoaded', function() {
            const header = document.querySelector('.header');
            const userEmail = localStorage.getItem('ventilation_user_email') || 'User';
            
            const userSection = document.createElement('div');
            userSection.style.cssText = 'position: absolute; top: 15px; right: 20px; font-size: 0.9em;';
            userSection.innerHTML = `
                <span style="margin-right: 15px;">Welcome, ${userEmail}</span>
                <button onclick="logout()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">Logout</button>
            `;
            
            header.style.position = 'relative';
            header.appendChild(userSection);
            
            // Add no-data notice if no authentication is provided
            const token = localStorage.getItem('ventilation_auth_token');
            if (!CONFIG.apiSecret && !token) {
                const noDataNotice = document.createElement('div');
                noDataNotice.style.cssText = 'background: rgba(255,193,7,0.9); color: #212529; padding: 10px; text-align: center; font-size: 0.9em; border-radius: 5px; margin-top: 10px;';
                noDataNotice.innerHTML = 'üìä <strong>No Data Available:</strong> Data is currently unavailable. <a href="login.html" style="color: #0056b3; text-decoration: underline;">Log in</a> or add <code>?apikey=VentilationSystem2025SecretKey</code> to URL for live data.';
                header.appendChild(noDataNotice);
            }
            
            initializeDashboard();
        });

        // Initialize dashboard
        async function initializeDashboard() {
            await refreshData();
            // Load default 6-hour chart
            await loadChart(6); // Load 6-hour chart by default
            
            // Load incident trends chart
            await loadIncidentTrends();
            
            // Start auto-refresh
            startAutoRefresh();
        }

        async function refreshData() {
            try {
                updateConnectionStatus('connecting');
                
                const token = localStorage.getItem('ventilation_auth_token');
                
                // If no authentication method is available, show no data
                if (!token && !CONFIG.apiSecret) {
                    // No authentication available, show no data state
                    showNoDataState();
                    updateConnectionStatus('disconnected');
                    return;
                }
                
                const response = await fetch(`${CONFIG.statusApiUrl}?deviceId=${CONFIG.deviceId}`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (response.status === 401) {
                    // Only logout if using API key authentication
                    // For Bearer token, fall back to mock data until functions are updated
                    const token = localStorage.getItem('ventilation_auth_token');
                    if (!token && CONFIG.apiSecret) {
                        // Using API key and got 401 - logout
                        logout();
                        return;
                    } else if (token) {
                        // Using Bearer token but got 401 - functions may not support it yet
                        // Bearer token authentication failed, show no data state
                        showApiFailureNotice('Status API returned 401 Unauthorized. Please check authentication or contact system administrator.', 'error');
                        showNoDataState();
                        updateConnectionStatus('disconnected');
                        return;
                    }
                }
                
                if (!response.ok) {
                    // Log the error details for debugging
                    console.error(`API Error: ${response.status} ${response.statusText}`);
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    
                    // If unauthorized and no API secret, show no data
                    if (response.status === 401 || response.status === 404) {
                        // API call failed, show no data state
                        showApiFailureNotice(`Status API returned ${response.status} ${response.statusText}. Data is currently unavailable.`, 'error');
                        showNoDataState();
                        updateConnectionStatus('disconnected');
                        return;
                    }
                    showApiFailureNotice(`Status API returned ${response.status} ${response.statusText}. Data is currently unavailable.`, 'error');
                    showNoDataState();
                    updateConnectionStatus('disconnected');
                    return;
                }
                
                const data = await response.json();
                updateDashboard(data);
                updateConnectionStatus('connected');

                // Refresh chart data if chart is currently displayed
                refreshCurrentChart();
            } catch (error) {
                console.error('Error fetching data:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    token: localStorage.getItem('ventilation_auth_token') ? 'Present' : 'Missing',
                    apiSecret: CONFIG.apiSecret ? 'Present' : 'Missing'
                });
                
                // Show no data instead of mock data
                // Network error, show no data state
                showApiFailureNotice(`Network error connecting to Status API: ${error.message}. Data is currently unavailable.`, 'error');
                showNoDataState();
                updateConnectionStatus('disconnected');
            }
        }

        function showNoDataState() {
            // Hide loading, show content with no data message
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('dashboardContent').style.display = 'block';

            // Set all sensor readings to "No data"
            document.getElementById('indoorTemp').textContent = 'No data';
            document.getElementById('indoorHumidity').textContent = 'No data';
            document.getElementById('indoorPressure').textContent = 'No data';
            document.getElementById('outdoorTemp').textContent = 'No data';
            document.getElementById('outdoorHumidity').textContent = 'No data';
            document.getElementById('outdoorPressure').textContent = 'No data';
            document.getElementById('garageTemp').textContent = 'No data';
            document.getElementById('garageHumidity').textContent = 'No data';
            document.getElementById('garagePressure').textContent = 'No data';

            // Set system status to no data
            document.getElementById('fanStatus').textContent = '‚ùì';
            document.getElementById('fanStatus').className = 'fan-status';
            document.getElementById('fanStatusText').textContent = 'No data';
            document.getElementById('ventilationMode').textContent = 'No data';
            document.getElementById('fanMinutes').textContent = 'No data';
            document.getElementById('freshAirStatus').textContent = 'No data';
            document.getElementById('ventilationHours').textContent = 'No data';
            document.getElementById('coolingEffect').textContent = 'No data';

            // Set weather to no data
            document.getElementById('forecastHigh').textContent = 'No data';
            document.getElementById('stormRisk').textContent = 'No data';
            document.getElementById('stormRiskExplanation').textContent = 'Storm risk status will be explained here.';

            // Set system info to no data
            document.getElementById('uptime').textContent = 'No data';
            
            // Set reliability info to no data (only elements that still exist)
            document.getElementById('rebootCount').textContent = 'No data';
            document.getElementById('wifiOutageCount').textContent = 'No data';

            // Hide door section since no data
            document.getElementById('doorSection').style.display = 'none';

            // Update last update time
            document.getElementById('lastUpdate').textContent = 'No data available';
        }

        function updateDashboard(data) {
            // Hide loading, show content
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('dashboardContent').style.display = 'block';

            // Update sensors with proper null/undefined handling
            const sensors = data.sensors || {};
            const indoor = sensors.indoor || {};
            const outdoor = sensors.outdoor || {};
            const garage = sensors.garage || {};
            
            document.getElementById('indoorTemp').textContent = indoor.temp != null ? `${indoor.temp.toFixed(1)}¬∞F` : 'No data';
            document.getElementById('indoorHumidity').textContent = indoor.humidity != null ? `${indoor.humidity.toFixed(0)}%` : 'No data';
            document.getElementById('indoorPressure').textContent = indoor.pressure != null ? `${indoor.pressure.toFixed(2)} inHg` : 'No data';
            
            document.getElementById('outdoorTemp').textContent = outdoor.temp != null ? `${outdoor.temp.toFixed(1)}¬∞F` : 'No data';
            document.getElementById('outdoorHumidity').textContent = outdoor.humidity != null ? `${outdoor.humidity.toFixed(0)}%` : 'No data';
            document.getElementById('outdoorPressure').textContent = outdoor.pressure != null ? `${outdoor.pressure.toFixed(2)} inHg` : 'No data';
            
            document.getElementById('garageTemp').textContent = garage.temp != null ? `${garage.temp.toFixed(1)}¬∞F` : 'No data';
            document.getElementById('garageHumidity').textContent = garage.humidity != null ? `${garage.humidity.toFixed(0)}%` : 'No data';
            document.getElementById('garagePressure').textContent = garage.pressure != null ? `${garage.pressure.toFixed(2)} inHg` : 'No data';

            // Update system status with proper null/undefined handling
            const system = data.system || {};
            const fanOn = system.fanOn;
            
            if (fanOn != null) {
                document.getElementById('fanStatus').textContent = fanOn ? 'üåÄ' : '‚è∏Ô∏è';
                document.getElementById('fanStatus').className = `fan-status ${fanOn ? 'fan-on' : 'fan-off'}`;
                document.getElementById('fanStatusText').textContent = fanOn ? 'RUNNING' : 'STOPPED';
            } else {
                document.getElementById('fanStatus').textContent = '‚ùì';
                document.getElementById('fanStatus').className = 'fan-status';
                document.getElementById('fanStatusText').textContent = 'No data';
            }
            
            document.getElementById('ventilationMode').textContent = system.ventilationMode || 'No data';
            document.getElementById('fanMinutes').textContent = system.fanMinutesToday != null ? system.fanMinutesToday : 'No data';
            document.getElementById('freshAirStatus').textContent = system.freshAirActive != null ? (system.freshAirActive ? 'Active' : 'Inactive') : 'No data';
            document.getElementById('ventilationHours').textContent = system.operatingHours || 'No data';
            
            // Calculate and display cooling effect
            const coolingEffect = calculateCoolingEffect(
                indoor.temp, 
                outdoor.temp, 
                system.fanMinutesToday, 
                fanOn
            );
            document.getElementById('coolingEffect').textContent = coolingEffect;

            // Update weather with proper null/undefined handling
            const weather = data.weather || {};
            const stormRiskValue = weather.stormRisk || 'No data';
            document.getElementById('forecastHigh').textContent = weather.forecastHigh != null ? `${weather.forecastHigh.toFixed(0)}¬∞F` : 'No data';
            document.getElementById('stormRisk').textContent = stormRiskValue;
            
            // Update storm risk explanation based on the actual value
            const stormRiskExplanation = document.getElementById('stormRiskExplanation');
            if (stormRiskValue && stormRiskValue !== 'No data') {
                const explanations = {
                    'Clear': 'Stable pressure - no significant changes over 3 hours.',
                    'Possible': 'Low pressure below 1000 hPa detected.',
                    'Likely': 'Pressure drop >3 hPa over 3 hours detected.',
                    'Imminent': 'Rapid pressure drop >5 hPa over 3 hours detected!'
                };
                stormRiskExplanation.textContent = explanations[stormRiskValue] || `${stormRiskValue} - pressure trend indicates weather change.`;
            } else {
                stormRiskExplanation.textContent = 'Storm risk status will be explained here.';
            }
            
            // Update system info with proper null/undefined handling
            const uptimeHours = system.uptime != null ? Math.floor(system.uptime / 3600) : null;
            document.getElementById('uptime').textContent = uptimeHours != null ? `${uptimeHours}h` : 'No data';

            // Update reliability statistics with proper null/undefined handling (only elements that still exist)
            const reliability = data.reliability || {};
            document.getElementById('rebootCount').textContent = reliability.rebootCount != null ? reliability.rebootCount : 'No data';
            document.getElementById('wifiOutageCount').textContent = reliability.wifiOutageCount != null ? reliability.wifiOutageCount : 'No data';

            // Update incidents if available
            if (data.incidents) {
                updateIncidents(data.incidents);
            }

            // Update doors if available
            if (data.doors && data.doors.length > 0) {
                updateDoorStatus(data.doors);
            }

            // Check for alerts
            checkAlerts(data);

            // Update last update time
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        function updateDoorStatus(doors) {
            const doorSection = document.getElementById('doorSection');
            const doorList = document.getElementById('doorList');
            
            if (doors.length === 0) {
                doorSection.style.display = 'none';
                return;
            }

            doorSection.style.display = 'block';
            doorList.innerHTML = '';

            doors.forEach(door => {
                const doorItem = document.createElement('div');
                doorItem.className = 'door-item';
                doorItem.style.cssText = `
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    padding: 15px;
                    margin-bottom: 10px;
                    background: ${door.open ? '#fff5f5' : '#f8fff8'};
                    border-color: ${door.open ? '#ffcccb' : '#ccffcc'};
                `;
                
                // Format timestamps
                const formatTime = (timestamp) => {
                    if (!timestamp || timestamp === '0') return 'N/A';
                    const date = new Date(parseInt(timestamp) * 1000);
                    const now = new Date();
                    const isToday = date.toDateString() === now.toDateString();
                    
                    if (isToday) {
                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    } else {
                        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                };
                
                const formatDuration = (minutes) => {
                    if (minutes < 60) return `${minutes}m`;
                    const hours = Math.floor(minutes / 60);
                    const mins = minutes % 60;
                    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                };
                
                // Door name and current status
                let statusHtml = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="font-size: 1.1em;">${door.name || `Door ${door.id}`}</strong>
                        <span class="sensor-value ${door.open ? 'fan-on' : 'fan-off'}" style="font-size: 1.2em;">
                            ${door.open ? 'üîì OPEN' : 'üîí CLOSED'}
                        </span>
                    </div>
                `;
                
                // Current session info
                if (door.open) {
                    statusHtml += `
                        <div class="door-detail">
                            <strong>Current Session:</strong>
                            <div style="margin-left: 15px;">
                                ‚Ä¢ Opened at: ${formatTime(door.openedAt)}<br>
                                ‚Ä¢ Duration: ${formatDuration(door.minutesOpen || 0)}
                            </div>
                        </div>
                    `;
                }
                
                // Daily summary
                if (door.wasOpenedToday) {
                    statusHtml += `
                        <div class="door-detail" style="margin-top: 10px;">
                            <strong>Today's Activity:</strong>
                            <div style="margin-left: 15px;">
                                ‚Ä¢ Total time open: ${formatDuration(door.minutesTotalToday || 0)}<br>
                                ‚Ä¢ First opened: ${formatTime(door.firstOpenedToday)}<br>
                                ‚Ä¢ Last opened: ${formatTime(door.lastOpenedToday)}
                            </div>
                        </div>
                    `;
                } else {
                    statusHtml += `
                        <div class="door-detail" style="margin-top: 10px; color: #666;">
                            <strong>Today's Activity:</strong> Not opened today
                        </div>
                    `;
                }
                
                doorItem.innerHTML = statusHtml;
                doorList.appendChild(doorItem);
            });
        }

        function updateIncidents(incidents) {
            const incidentsList = document.getElementById('incidentsList');
            const incidentsSummary = document.getElementById('incidentsSummary');
            
            // Store original data for filtering
            originalIncidentsData = incidents || [];
            
            if (!incidents || incidents.length === 0) {
                incidentsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No incidents recorded in the last 30 days</div>';
                incidentsSummary.innerHTML = '<strong>All systems operating normally</strong> - No incidents detected';
                document.getElementById('filterStatus').textContent = 'No incident data available';
                return;
            }

            // Filter out incidents with corrupted timestamps (same issue as chart data)
            function isValidIncidentTimestamp(timestamp) {
                if (!timestamp || timestamp === 0) return false;
                
                // Convert to Date object
                const date = new Date(timestamp * 1000); // Incidents use Unix timestamps in seconds
                
                // Validate date and check year range
                if (isNaN(date.getTime())) return false;
                const year = date.getFullYear();
                return year >= 2020 && year <= 2030;
            }
            
            // Filter incidents with valid timestamps
            const validIncidents = incidents.filter(incident => {
                const validStart = isValidIncidentTimestamp(incident.startTime);
                const validEnd = incident.endTime === 0 || isValidIncidentTimestamp(incident.endTime);
                return validStart && validEnd;
            });
            
            console.log(`Incidents: ${incidents.length} total, ${validIncidents.length} with valid timestamps`);
            
            if (validIncidents.length === 0) {
                incidentsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No valid incidents found in the last 30 days (some data may be corrupted)</div>';
                incidentsSummary.innerHTML = '<strong>No valid incident data available</strong> - Check for data corruption';
                document.getElementById('filterStatus').textContent = 'No valid incident data available';
                return;
            }

            // Store the valid incidents for filtering
            originalIncidentsData = validIncidents;
            
            // Reset filters to default values and apply them
            document.getElementById('timePeriodFilter').value = '7'; // Default to last week
            document.getElementById('severityFilter').value = 'all';
            applyIncidentFilters();
        }

        // Global variable to store original incidents data for filtering
        let originalIncidentsData = [];

        // Function to apply both time period and severity filters
        function applyIncidentFilters() {
            const timePeriodValue = document.getElementById('timePeriodFilter').value;
            const severityValue = document.getElementById('severityFilter').value;
            const filterStatus = document.getElementById('filterStatus');
            
            if (!originalIncidentsData || originalIncidentsData.length === 0) {
                filterStatus.textContent = 'No incident data available';
                return;
            }
            
            // First filter by time period
            const now = new Date();
            const cutoffDays = parseInt(timePeriodValue);
            const cutoffTime = new Date(now.getTime() - (cutoffDays * 24 * 60 * 60 * 1000));
            const cutoffTimestamp = Math.floor(cutoffTime.getTime() / 1000);
            
            let timeFilteredIncidents = originalIncidentsData.filter(incident => {
                // Always include ongoing incidents (endTime = 0) regardless of start time
                if (incident.endTime === 0) {
                    return true;
                }
                // For completed incidents, check if they started within the time period
                return incident.startTime >= cutoffTimestamp;
            });
            
            // Then filter by severity
            let filteredIncidents;
            if (severityValue === 'all') {
                filteredIncidents = timeFilteredIncidents;
            } else {
                const maxSeverity = parseInt(severityValue);
                filteredIncidents = timeFilteredIncidents.filter(incident => incident.severity <= maxSeverity);
            }
            
            // Build filter description
            let filterDescription = '';
            
            // Time period description
            if (cutoffDays === 1) {
                filterDescription += 'Last 24 hours';
            } else if (cutoffDays === 7) {
                filterDescription += 'Last week';
            } else if (cutoffDays === 30) {
                filterDescription += 'Last 30 days';
            } else {
                filterDescription += `Last ${cutoffDays} days`;
            }
            
            // Severity description
            if (severityValue !== 'all') {
                const severityNames = ['Critical', 'High', 'Medium', 'Low'];
                const maxSeverity = parseInt(severityValue);
                if (maxSeverity === 0) {
                    filterDescription += ' ‚Ä¢ Critical only';
                } else {
                    filterDescription += ` ‚Ä¢ ${severityNames[maxSeverity]} and above`;
                }
            }
            
            filterStatus.textContent = `${filterDescription} (${filteredIncidents.length} of ${originalIncidentsData.length} total incidents)`;
            
            // Re-render incidents with filtered data
            renderFilteredIncidents(filteredIncidents, cutoffDays);
        }

        // Function to render filtered incidents (extracted from updateIncidents)
        function renderFilteredIncidents(incidents, timePeriodDays = 30) {
            const incidentsList = document.getElementById('incidentsList');
            const incidentsSummary = document.getElementById('incidentsSummary');
            
            if (!incidents || incidents.length === 0) {
                const timePeriodText = timePeriodDays === 1 ? 'last 24 hours' : 
                                     timePeriodDays === 7 ? 'last week' : 
                                     timePeriodDays === 30 ? 'last 30 days' : 
                                     `last ${timePeriodDays} days`;
                incidentsList.innerHTML = `<div style="text-align: center; padding: 20px; color: #666;">No incidents found in ${timePeriodText} with current filters</div>`;
                incidentsSummary.innerHTML = `<strong>Filtered results:</strong> No incidents`;
                return;
            }

            // Filter out incidents with corrupted timestamps (same validation as in updateIncidents)
            function isValidIncidentTimestamp(timestamp) {
                if (!timestamp || timestamp <= 0) return false;
                
                const date = new Date(timestamp * 1000);
                if (isNaN(date.getTime())) return false;
                
                const year = date.getFullYear();
                return year >= 2020 && year <= 2030;
            }
            
            const validIncidents = incidents.filter(incident => {
                const validStart = isValidIncidentTimestamp(incident.startTime);
                const validEnd = incident.endTime === 0 || isValidIncidentTimestamp(incident.endTime);
                return validStart && validEnd;
            });
            
            if (validIncidents.length === 0) {
                incidentsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No valid incidents found matching the filter (some data may be corrupted)</div>';
                incidentsSummary.innerHTML = `<strong>Filtered results:</strong> No valid incidents`;
                return;
            }

            // Sort incidents by start time (newest first)
            const sortedIncidents = validIncidents.sort((a, b) => b.startTime - a.startTime);
            
            // Define incident type names and icons
            const incidentTypes = {
                0: { name: 'Power Loss', icon: '‚ö°' },
                1: { name: 'WiFi Down', icon: 'üì∂' },
                2: { name: 'Internet Down', icon: 'ÔøΩ' },
                3: { name: 'API Down', icon: '‚òÅÔ∏è' },
                4: { name: 'Storm Event', icon: 'üå©Ô∏è' },
                5: { name: 'Heat Event', icon: 'üî•' },
                6: { name: 'Freeze Event', icon: 'üßä' }
            };
            
            const severityNames = ['Critical', 'High', 'Medium', 'Low'];
            const severityClasses = ['incident-critical', 'incident-high', 'incident-medium', 'incident-low'];
            
            // Build incidents HTML
            let incidentsHtml = '';
            for (const incident of sortedIncidents) { // Show all filtered incidents
                const typeInfo = incidentTypes[incident.type] || { name: 'Unknown', icon: '‚ùì' };
                const severity = severityNames[incident.severity] || 'Unknown';
                const severityClass = severityClasses[incident.severity] || 'incident-low';
                
                const startTime = new Date(incident.startTime * 1000);
                const endTime = incident.endTime > 0 ? new Date(incident.endTime * 1000) : null;
                
                const formatDateTime = (date) => {
                    const now = new Date();
                    const isToday = date.toDateString() === now.toDateString();
                    const isYesterday = date.toDateString() === new Date(now.getTime() - 86400000).toDateString();
                    
                    if (isToday) {
                        return `Today ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                    } else if (isYesterday) {
                        return `Yesterday ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                    } else {
                        return date.toLocaleDateString([], {month: 'short', day: 'numeric'}) + ' ' + 
                               date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    }
                };
                
                const formatDuration = (seconds) => {
                    if (seconds < 60) return `${seconds}s`;
                    if (seconds < 3600) return `${Math.floor(seconds/60)}m ${seconds%60}s`;
                    const hours = Math.floor(seconds/3600);
                    const mins = Math.floor((seconds%3600)/60);
                    return `${hours}h ${mins}m`;
                };
                
                const duration = incident.endTime > 0 ? 
                    formatDuration(incident.endTime - incident.startTime) : 'Ongoing';
                
                const timeRange = endTime ? 
                    `${formatDateTime(startTime)} - ${formatDateTime(endTime)} (${duration})` :
                    `${formatDateTime(startTime)} - Ongoing`;
                
                incidentsHtml += `
                    <div class="incident-item ${severityClass}">
                        <div class="incident-header">
                            ${typeInfo.icon} ${severity} ${typeInfo.name}
                        </div>
                        <div class="incident-details">
                            ${timeRange}
                        </div>
                    </div>
                `;
            }
            
            incidentsList.innerHTML = incidentsHtml;
            
            // Build summary using filtered incidents
            const totalIncidents = validIncidents.length;
            const severityCounts = [0, 0, 0, 0];
            validIncidents.forEach(incident => {
                if (incident.severity >= 0 && incident.severity <= 3) {
                    severityCounts[incident.severity]++;
                }
            });
            
            const summaryParts = [];
            if (totalIncidents === 1) {
                summaryParts.push('1 incident');
            } else {
                summaryParts.push(`${totalIncidents} incidents`);
            }
            
            if (severityCounts[0] > 0) summaryParts.push(`${severityCounts[0]} Critical`);
            if (severityCounts[1] > 0) summaryParts.push(`${severityCounts[1]} High`);
            if (severityCounts[2] > 0) summaryParts.push(`${severityCounts[2]} Medium`);
            if (severityCounts[3] > 0) summaryParts.push(`${severityCounts[3]} Low`);
            
            const timePeriodText = timePeriodDays === 1 ? 'last 24 hours' : 
                                 timePeriodDays === 7 ? 'last week' : 
                                 timePeriodDays === 30 ? 'last 30 days' : 
                                 `last ${timePeriodDays} days`;
            
            incidentsSummary.innerHTML = `<strong>${timePeriodText.charAt(0).toUpperCase() + timePeriodText.slice(1)}:</strong> ${summaryParts.join(' | ')}`;
        }

        function checkAlerts(data) {
            const alerts = [];
            const sensors = data.sensors || {};
            const system = data.system || {};
            const weather = data.weather || {};

            // Temperature alerts
            const indoorTemp = sensors.indoor?.temp || 0;
            if (indoorTemp > 85) {
                alerts.push({type: 'danger', message: `High indoor temperature: ${indoorTemp.toFixed(1)}¬∞F`});
            } else if (indoorTemp < 60) {
                alerts.push({type: 'warning', message: `Low indoor temperature: ${indoorTemp.toFixed(1)}¬∞F`});
            }

            const garageTemp = sensors.garage?.temp || 0;
            if (garageTemp > 95) {
                alerts.push({type: 'danger', message: `High garage temperature: ${garageTemp.toFixed(1)}¬∞F`});
            } else if (garageTemp < 35) {
                alerts.push({type: 'warning', message: `Low garage temperature: ${garageTemp.toFixed(1)}¬∞F`});
            }

            // System alerts
            const freeHeap = system.freeHeap || 0;
            if (freeHeap < 50000) {
                alerts.push({type: 'warning', message: `Low memory: ${Math.round(freeHeap/1024)}KB available`});
            }

            // Storm alerts
            const stormRisk = weather.stormRisk || 'NONE';
            if (stormRisk === 'STORM_LIKELY' || stormRisk === 'STORM_IMMINENT') {
                alerts.push({type: 'warning', message: `Weather alert: ${stormRisk.replace('_', ' ')}`});
            }

            // Door alerts
            if (data.doors) {
                data.doors.forEach(door => {
                    if (door.open && door.minutesOpen > 240) { // 4 hours
                        alerts.push({type: 'warning', message: `${door.name || 'Door'} open for ${door.minutesOpen} minutes`});
                    }
                });
            }

            updateAlerts(alerts);
        }

        function updateAlerts(alerts) {
            const alertSection = document.getElementById('alertSection');
            const alertList = document.getElementById('alertList');

            if (alerts.length === 0) {
                alertSection.style.display = 'none';
                return;
            }

            alertSection.style.display = 'block';
            alertList.innerHTML = '';

            alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${alert.type}`;
                alertDiv.textContent = alert.message;
                alertList.appendChild(alertDiv);
            });
        }

        async function loadChart(hours) {
            // Track the current chart time period
            currentChartHours = hours;            // Update active button - find the button with matching hours
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.remove('active');
                // Check if this button's onclick matches the requested hours
                const onclick = btn.getAttribute('onclick');
                if (onclick && onclick.includes(`loadChart(${hours})`)) {
                    btn.classList.add('active');
                }
            });

            try {
                const token = localStorage.getItem('ventilation_auth_token');
                
                // If no authentication method is available, show empty chart
                if (!token && !CONFIG.apiSecret) {
                    // No authentication available, show empty chart
                    updateChart([], hours);
                    return;
                }

                const response = await fetch(`${CONFIG.historyApiUrl}?deviceId=${CONFIG.deviceId}&hours=${hours}`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (response.status === 401) {
                    // Only logout if using API key authentication
                    // For Bearer token, fall back to mock data until functions are updated
                    const token = localStorage.getItem('ventilation_auth_token');
                    if (!token && CONFIG.apiSecret) {
                        // Using API key and got 401 - logout
                        logout();
                        return;
                    } else if (token) {
                        // Using Bearer token but got 401 - functions may not support it yet
                        // Bearer token chart authentication failed, show empty chart
                        showApiFailureNotice('History API returned 401 Unauthorized. Chart data is currently unavailable.', 'warning');
                        updateChart([], hours);
                        return;
                    }
                }
                
                if (!response.ok) {
                    // Show empty chart if API fails
                    // Chart API call failed, show empty chart
                    showApiFailureNotice(`History API returned ${response.status} ${response.statusText}. Chart data is currently unavailable.`, 'warning');
                    updateChart([], hours);
                    return;
                }
                
                const data = await response.json();
                if (data.data && data.data.length > 0) {
                    try {
                        const firstTimestamp = new Date(data.data[0].timestamp);
                        const lastTimestamp = new Date(data.data[data.data.length - 1].timestamp);
                        
                        // Check if timestamps are valid before trying to use them
                        if (!isNaN(firstTimestamp.getTime()) && !isNaN(lastTimestamp.getTime())) {
                            const apiSpanHours = (lastTimestamp.getTime() - firstTimestamp.getTime()) / (1000 * 60 * 60);
                            // API data span calculated for internal tracking
                        }
                    } catch (timestampError) {
                        // Error parsing timestamps for logging, proceeding with chart update
                    }
                }
                updateChart(data.data || [], hours);
                
            } catch (error) {
                console.error('Error loading chart data:', error);
                // Show empty chart instead of mock data
                showApiFailureNotice(`Network error loading chart data: ${error.message}. Chart data is currently unavailable.`, 'warning');
                updateChart([], hours);
            }
        }

        // Function to refresh the currently displayed chart without changing time period
        async function refreshCurrentChart() {
            if (temperatureChart) {
                // Check if there's new chart data before refreshing
                await checkAndRefreshChart(currentChartHours);
            }
        }

        // Smart chart refresh - only refreshes if new data is available
        async function checkAndRefreshChart(hours) {
            try {
                const token = localStorage.getItem('ventilation_auth_token');
                
                // If no authentication method is available, skip chart refresh
                if (!token && !CONFIG.apiSecret) {
                    return;
                }

                const response = await fetch(`${CONFIG.historyApiUrl}?deviceId=${CONFIG.deviceId}&hours=${hours}`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    // Don't refresh chart if API fails
                    return;
                }
                
                const data = await response.json();
                if (!data.data || data.data.length === 0) {
                    // No data available, don't refresh
                    return;
                }

                // Get the latest timestamp from the new data
                const latestDataPoint = data.data[0]; // API returns newest first
                let newLatestTimestamp = null;

                // Parse the timestamp from the latest data point
                if (latestDataPoint.timestamp) {
                    if (typeof latestDataPoint.timestamp === 'string') {
                        if (latestDataPoint.timestamp.includes('T') || latestDataPoint.timestamp.includes('-')) {
                            newLatestTimestamp = new Date(latestDataPoint.timestamp);
                        } else {
                            const unixSeconds = parseInt(latestDataPoint.timestamp);
                            if (!isNaN(unixSeconds) && unixSeconds > 1000000000) {
                                newLatestTimestamp = new Date(unixSeconds * 1000);
                            } else {
                                newLatestTimestamp = new Date(latestDataPoint.timestamp);
                            }
                        }
                    } else if (typeof latestDataPoint.timestamp === 'number') {
                        const timestamp = latestDataPoint.timestamp;
                        newLatestTimestamp = timestamp < 10000000000 ? new Date(timestamp * 1000) : new Date(timestamp);
                    } else {
                        newLatestTimestamp = new Date(latestDataPoint.timestamp);
                    }
                }

                // If we can't parse the timestamp, refresh anyway to be safe
                if (!newLatestTimestamp || isNaN(newLatestTimestamp.getTime())) {
                    console.log('Chart refresh: Unable to parse timestamp, refreshing anyway');
                    updateChart(data.data, hours);
                    return;
                }

                // Check if this is newer than our stored latest timestamp
                if (!latestChartDataTimestamp || newLatestTimestamp > latestChartDataTimestamp) {
                    console.log(`Chart refresh: New data available (${newLatestTimestamp.toLocaleTimeString()})`, {
                        previous: latestChartDataTimestamp ? latestChartDataTimestamp.toLocaleTimeString() : 'none',
                        new: newLatestTimestamp.toLocaleTimeString()
                    });
                    
                    // Update our stored timestamp and refresh the chart
                    latestChartDataTimestamp = newLatestTimestamp;
                    updateChart(data.data, hours);
                } else {
                    console.log('Chart refresh: No new data, skipping refresh', {
                        latest: latestChartDataTimestamp.toLocaleTimeString(),
                        checked: newLatestTimestamp.toLocaleTimeString()
                    });
                }

            } catch (error) {
                console.error('Error checking for new chart data:', error);
                // On error, don't refresh to avoid unnecessary animations
            }
        }

        function updateChart(data, requestedHours = 6) {
            const ctx = document.getElementById('temperatureChart').getContext('2d');
            
            // Update latest timestamp tracking for smart refresh
            if (data && data.length > 0) {
                const latestDataPoint = data[0]; // API returns newest first
                if (latestDataPoint.timestamp) {
                    let timestamp;
                    if (typeof latestDataPoint.timestamp === 'string') {
                        if (latestDataPoint.timestamp.includes('T') || latestDataPoint.timestamp.includes('-')) {
                            timestamp = new Date(latestDataPoint.timestamp);
                        } else {
                            const unixSeconds = parseInt(latestDataPoint.timestamp);
                            if (!isNaN(unixSeconds) && unixSeconds > 1000000000) {
                                timestamp = new Date(unixSeconds * 1000);
                            } else {
                                timestamp = new Date(latestDataPoint.timestamp);
                            }
                        }
                    } else if (typeof latestDataPoint.timestamp === 'number') {
                        const ts = latestDataPoint.timestamp;
                        timestamp = ts < 10000000000 ? new Date(ts * 1000) : new Date(ts);
                    } else {
                        timestamp = new Date(latestDataPoint.timestamp);
                    }
                    
                    if (!isNaN(timestamp.getTime())) {
                        latestChartDataTimestamp = timestamp;
                    }
                }
            }
            
            // Destroy existing chart
            if (temperatureChart) {
                temperatureChart.destroy();
            }

            // If no data, create a simple "no data" chart
            if (!data || data.length === 0) {
                temperatureChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No Data Available'],
                        datasets: [{
                            label: 'No Data',
                            data: [0],
                            borderColor: '#ddd',
                            backgroundColor: 'rgba(221, 221, 221, 0.1)',
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: {
                                    generateLabels: function() {
                                        return [{
                                            text: 'No data available - check authentication or API connection',
                                            fillStyle: '#ddd',
                                            strokeStyle: '#ddd'
                                        }];
                                    }
                                }
                            }
                        },
                        scales: {
                            y: { 
                                display: true,
                                title: { display: true, text: 'Waiting for data...' }
                            },
                            x: { 
                                display: true,
                                title: { display: true, text: 'Time' }
                            }
                        }
                    }
                });
                return;
            }
            
            // Data comes from API in reverse chronological order (newest first)
            // We need to reverse it to show oldest to newest (left to right)
            let sortedData = [...data].reverse();
            
            // Filter out corrupted data with invalid timestamps (fix for chart showing years 1954, 1963, 1972, 1981)
            function isValidTimestamp(timestamp) {
                let date;
                
                if (typeof timestamp === 'string') {
                    if (timestamp.includes('T') || timestamp.includes('-')) {
                        date = new Date(timestamp);
                    } else {
                        const unixSeconds = parseInt(timestamp);
                        if (!isNaN(unixSeconds) && unixSeconds > 1000000000 && unixSeconds < 2000000000) {
                            date = new Date(unixSeconds * 1000);
                        } else {
                            return false;
                        }
                    }
                } else if (typeof timestamp === 'number') {
                    if (timestamp < 1000000000 || timestamp > 2000000000) {
                        return false; // Invalid Unix timestamp range
                    }
                    date = timestamp < 10000000000 ? new Date(timestamp * 1000) : new Date(timestamp);
                } else {
                    return false;
                }
                
                // Reject timestamps before 2020 or after 2030 (likely corrupted)
                const year = date.getFullYear();
                return !isNaN(date.getTime()) && year >= 2020 && year <= 2030;
            }
            
            // Filter out items with corrupted timestamps
            sortedData = sortedData.filter(item => {
                if (!item.timestamp) return false;
                return isValidTimestamp(item.timestamp);
            });
            
            console.log(`Chart data: ${data.length} total items, ${sortedData.length} valid items after timestamp filtering`);
            
            // Debug: Log sample timestamps from the API
            if (data.length > 0) {
                console.log('Sample raw timestamps from API:', data.slice(0, 3).map(item => ({
                    timestamp: item.timestamp,
                    type: typeof item.timestamp
                })));
            }
            
            if (sortedData.length > 0) {
                console.log('Sample timestamps after filtering:', sortedData.slice(0, 3).map(item => item.timestamp));
            }
            
            // Prepare time-based data points for proper temporal spacing
            const timeBasedData = sortedData.map((item, index) => {
                let date;
                
                // Handle different timestamp formats with enhanced validation
                if (typeof item.timestamp === 'string') {
                    if (item.timestamp.includes('T') || item.timestamp.includes('-')) {
                        date = new Date(item.timestamp);
                    } else {
                        const unixSeconds = parseInt(item.timestamp);
                        if (!isNaN(unixSeconds) && unixSeconds > 1000000000 && unixSeconds < 2000000000) {
                            date = new Date(unixSeconds * 1000);
                        } else {
                            console.warn('Invalid Unix timestamp:', item.timestamp);
                            return null; // Skip this item
                        }
                    }
                } else if (typeof item.timestamp === 'number') {
                    if (item.timestamp < 1000000000 || item.timestamp > 2000000000) {
                        console.warn('Invalid numeric timestamp:', item.timestamp);
                        return null; // Skip this item
                    }
                    date = item.timestamp < 10000000000 ? new Date(item.timestamp * 1000) : new Date(item.timestamp);
                } else {
                    console.warn('Unknown timestamp format:', item.timestamp);
                    return null; // Skip this item
                }
                
                // Final validation - reject if date is invalid or outside reasonable range
                if (isNaN(date.getTime())) {
                    console.warn('Failed to parse timestamp:', item.timestamp);
                    return null;
                }
                
                const year = date.getFullYear();
                if (year < 2020 || year > 2030) {
                    console.warn('Timestamp outside valid range (corrupted):', date.toISOString(), 'from:', item.timestamp);
                    return null;
                }
                
                return {
                    timestamp: date,
                    item: item
                };
            }).filter(dataPoint => dataPoint !== null); // Remove null entries

            // Debug: Log the final timestamp range being sent to chart
            if (timeBasedData.length > 0) {
                const timestamps = timeBasedData.map(d => d.timestamp);
                const minTime = new Date(Math.min(...timestamps));
                const maxTime = new Date(Math.max(...timestamps));
                console.log('Chart timestamp range:', {
                    earliest: minTime.toISOString(),
                    latest: maxTime.toISOString(),
                    span: `${((maxTime - minTime) / (1000 * 60 * 60)).toFixed(1)} hours`,
                    count: timeBasedData.length
                });
            }

            // Extract the actual sensor data with timestamps for Chart.js time scale
            const indoorTemps = timeBasedData.map(dataPoint => {
                // Check if the item has the expected structure
                if (dataPoint.item.sensors && dataPoint.item.sensors.indoor && typeof dataPoint.item.sensors.indoor.temp === 'number') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.sensors.indoor.temp
                    };
                }
                return null;
            }).filter(point => point !== null);
            
            const outdoorTemps = timeBasedData.map(dataPoint => {
                if (dataPoint.item.sensors && dataPoint.item.sensors.outdoor && typeof dataPoint.item.sensors.outdoor.temp === 'number') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.sensors.outdoor.temp
                    };
                }
                return null;
            }).filter(point => point !== null);
            
            const garageTemps = timeBasedData.map(dataPoint => {
                if (dataPoint.item.sensors && dataPoint.item.sensors.garage && typeof dataPoint.item.sensors.garage.temp === 'number') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.sensors.garage.temp
                    };
                }
                return null;
            }).filter(point => point !== null);
            
            const fanStatus = timeBasedData.map(dataPoint => {
                if (dataPoint.item.system && typeof dataPoint.item.system.fanOn === 'boolean') {
                    return {
                        x: dataPoint.timestamp,
                        y: dataPoint.item.system.fanOn ? 1 : 0
                    };
                }
                return null;
            }).filter(point => point !== null);

            // Debug fan status data
            console.log('Fan status data points:', fanStatus.length);
            if (fanStatus.length > 0) {
                console.log('Sample fan status data:', fanStatus.slice(0, 3));
            }

            // Create new chart with time-based data
            temperatureChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Indoor Temperature (¬∞F)',
                            data: indoorTemps,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            tension: 0.4,
                            yAxisID: 'temp'
                        },
                        {
                            label: 'Outdoor Temperature (¬∞F)',
                            data: outdoorTemps,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.4,
                            yAxisID: 'temp'
                        },
                        {
                            label: 'Garage Temperature (¬∞F)',
                            data: garageTemps,
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            tension: 0.4,
                            yAxisID: 'temp'
                        },
                        {
                            label: 'Fan Status',
                            data: fanStatus,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.2)',
                            stepped: true,
                            fill: true,
                            tension: 0,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            yAxisID: 'fan'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        temp: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (¬∞F)'
                            }
                        },
                        fan: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 1,
                            title: {
                                display: true,
                                text: 'Fan Status'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value === 1 ? 'ON' : 'OFF';
                                }
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    minute: 'h:mm a',
                                    hour: 'h a',
                                    day: 'M/d'
                                },
                                tooltipFormat: 'MMM d, h:mm a'
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                maxRotation: 45,
                                minRotation: 0,
                                autoSkip: true
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Load and display incident trends chart
        async function loadIncidentTrends() {
            const viewType = document.getElementById('trendsViewFilter').value;
            const severityFilter = document.getElementById('trendsSeverityFilter').value;
            const trendsStatus = document.getElementById('trendsStatus');
            
            try {
                trendsStatus.textContent = 'Loading incident trends...';
                
                // Get 12 months of incident data
                const now = new Date();
                const oneYearAgo = new Date(now.getTime() - (365 * 24 * 60 * 60 * 1000));
                
                // Get temperature data for monthly view overlays
                let temperatureData = null;
                if (viewType === 'monthly') {
                    temperatureData = await fetchTemperatureDataForTrends();
                }
                
                // For now, we'll use the original incidents data if available
                // In a real implementation, you'd fetch data with a longer time range
                if (!originalIncidentsData || originalIncidentsData.length === 0) {
                    trendsStatus.textContent = 'No incident data available for trends analysis';
                    updateIncidentTrendsChart([], viewType, severityFilter, temperatureData);
                    return;
                }
                
                // Filter by severity
                let filteredIncidents = originalIncidentsData.filter(incident => {
                    if (severityFilter === 'critical') return incident.severity === 0;
                    if (severityFilter === 'high') return incident.severity === 1;
                    if (severityFilter === 'medium') return incident.severity === 2;
                    if (severityFilter === 'low') return incident.severity === 3;
                    if (severityFilter === 'critical-high') return incident.severity <= 1;
                    if (severityFilter === 'critical-high-medium') return incident.severity <= 2;
                    if (severityFilter === 'all') return incident.severity >= 0 && incident.severity <= 3;
                    return false;
                });
                
                // Filter by time range (last 12 months)
                const cutoffTimestamp = Math.floor(oneYearAgo.getTime() / 1000);
                filteredIncidents = filteredIncidents.filter(incident => incident.startTime >= cutoffTimestamp);
                
                trendsStatus.textContent = `Showing ${filteredIncidents.length} incidents over last 12 months`;
                updateIncidentTrendsChart(filteredIncidents, viewType, severityFilter, temperatureData);
                
            } catch (error) {
                console.error('Error loading incident trends:', error);
                trendsStatus.textContent = 'Error loading incident trends data';
                updateIncidentTrendsChart([], viewType, severityFilter, null);
            }
        }

        // Fetch temperature data for trends overlay
        async function fetchTemperatureDataForTrends() {
            try {
                const token = localStorage.getItem('ventilation_auth_token');
                
                // If no authentication method is available, return null
                if (!token && !CONFIG.apiSecret) {
                    return null;
                }

                // Fetch temperature data from multiple time windows to get broader coverage
                const responses = await Promise.all([
                    fetch(`${CONFIG.historyApiUrl}?deviceId=${CONFIG.deviceId}&hours=48`, {
                        method: 'GET',
                        headers: getAuthHeaders()
                    }),
                    fetch(`${CONFIG.historyApiUrl}?deviceId=${CONFIG.deviceId}&hours=168`, { // 7 days
                        method: 'GET',
                        headers: getAuthHeaders()
                    }),
                    fetch(`${CONFIG.historyApiUrl}?deviceId=${CONFIG.deviceId}&hours=720`, { // 30 days
                        method: 'GET',
                        headers: getAuthHeaders()
                    })
                ]);
                
                // Combine all valid responses
                let allTemperatureData = [];
                for (const response of responses) {
                    if (response.ok) {
                        const data = await response.json();
                        if (data.data && data.data.length > 0) {
                            allTemperatureData = allTemperatureData.concat(data.data);
                        }
                    }
                }
                
                // Remove duplicates based on timestamp and filter valid data
                const uniqueData = [];
                const seenTimestamps = new Set();
                
                allTemperatureData.forEach(item => {
                    const timestampKey = item.timestamp;
                    if (!seenTimestamps.has(timestampKey) && isValidTemperatureReading(item)) {
                        seenTimestamps.add(timestampKey);
                        uniqueData.push(item);
                    }
                });
                
                console.log(`Temperature data for trends: ${uniqueData.length} unique data points`);
                return uniqueData;
                
            } catch (error) {
                console.error('Error fetching temperature data for trends:', error);
                return null;
            }
        }

        // Helper function to validate temperature readings
        function isValidTemperatureReading(item) {
            if (!item.timestamp || !item.sensors) return false;
            
            // Validate timestamp (same logic as chart)
            let date;
            if (typeof item.timestamp === 'string') {
                if (item.timestamp.includes('T') || item.timestamp.includes('-')) {
                    date = new Date(item.timestamp);
                } else {
                    const unixSeconds = parseInt(item.timestamp);
                    if (!isNaN(unixSeconds) && unixSeconds > 1000000000 && unixSeconds < 2000000000) {
                        date = new Date(unixSeconds * 1000);
                    } else {
                        return false;
                    }
                }
            } else if (typeof item.timestamp === 'number') {
                if (item.timestamp < 1000000000 || item.timestamp > 2000000000) {
                    return false;
                }
                date = item.timestamp < 10000000000 ? new Date(item.timestamp * 1000) : new Date(item.timestamp);
            } else {
                return false;
            }
            
            const year = date.getFullYear();
            if (isNaN(date.getTime()) || year < 2020 || year > 2030) {
                return false;
            }
            
            // Check for valid temperature readings
            const indoor = item.sensors.indoor;
            const outdoor = item.sensors.outdoor;
            const garage = item.sensors.garage;
            
            return (indoor && typeof indoor.temp === 'number') ||
                   (outdoor && typeof outdoor.temp === 'number') ||
                   (garage && typeof garage.temp === 'number');
        }

        function updateIncidentTrendsChart(incidents, viewType, severityFilter, temperatureData = null) {
            const ctx = document.getElementById('incidentTrendsChart').getContext('2d');
            
            // Destroy existing chart
            if (incidentTrendsChart) {
                incidentTrendsChart.destroy();
            }
            
            // Define all incident types with colors and icons
            const incidentTypes = {
                0: { name: 'Power Loss', icon: '‚ö°', criticalColor: '#8B0000', highColor: '#FF6B6B', mediumColor: '#FFB347', lowColor: '#FFDD99' },
                1: { name: 'WiFi Down', icon: 'üì∂', criticalColor: '#FF4500', highColor: '#FFA500', mediumColor: '#FFD700', lowColor: '#FFFF99' },
                2: { name: 'Internet Down', icon: 'üåê', criticalColor: '#000080', highColor: '#6495ED', mediumColor: '#87CEEB', lowColor: '#B0E0E6' },
                3: { name: 'API Down', icon: '‚òÅÔ∏è', criticalColor: '#4682B4', highColor: '#87CEEB', mediumColor: '#ADD8E6', lowColor: '#E0F6FF' },
                4: { name: 'Storm Event', icon: 'üå©Ô∏è', criticalColor: '#483D8B', highColor: '#9370DB', mediumColor: '#BA55D3', lowColor: '#DDA0DD' },
                5: { name: 'Heat Event', icon: 'üî•', criticalColor: '#DC143C', highColor: '#FF69B4', mediumColor: '#FFB6C1', lowColor: '#FFCCCB' },
                6: { name: 'Freeze Event', icon: 'üßä', criticalColor: '#00CED1', highColor: '#20B2AA', mediumColor: '#48CAE4', lowColor: '#90E0EF' }
            };
            
            if (!incidents || incidents.length === 0) {
                // Create empty chart
                incidentTrendsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No Data Available'],
                        datasets: [{
                            label: 'No incidents to display',
                            data: [0],
                            backgroundColor: '#ddd'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            
            // Process incidents based on view type
            let chartData, chartLabels;
            
            if (viewType === 'weekly') {
                [chartData, chartLabels] = processWeeklyIncidentData(incidents, incidentTypes, severityFilter);
            } else {
                [chartData, chartLabels] = processMonthlyIncidentData(incidents, incidentTypes, severityFilter, temperatureData);
            }
            
            // Create the chart
            incidentTrendsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartLabels,
                    datasets: chartData
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: viewType === 'weekly' ? 'Weeks (Last 12 Months)' : 'Months'
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Incidents'
                            },
                            ticks: {
                                stepSize: 1
                            }
                        },
                        yTemp: viewType === 'monthly' && temperatureData ? {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Temperature (¬∞F)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        } : undefined
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const incidentType = incidentTypes[context.dataset.incidentType];
                                    const severity = context.dataset.severity;
                                    const count = context.parsed.y;
                                    if (count > 0) {
                                        return `${incidentType.icon} ${count} ${severity} ${incidentType.name}`;
                                    }
                                    return null;
                                },
                                footer: function(context) {
                                    const totalIncidents = context.reduce((sum, item) => sum + item.parsed.y, 0);
                                    let footer = totalIncidents > 0 ? `Total: ${totalIncidents} incidents` : '';
                                    
                                    // Add temperature stats for monthly view
                                    if (viewType === 'monthly' && temperatureData && context.length > 0) {
                                        const monthIndex = context[0].dataIndex;
                                        const tempStats = getTemperatureStatsForTooltip(monthIndex, chartLabels);
                                        if (tempStats) {
                                            footer += footer ? '\n' : '';
                                            footer += `Temp: ${tempStats.min}¬∞F - ${tempStats.max}¬∞F (avg ${tempStats.avg}¬∞F)`;
                                        }
                                    }
                                    
                                    return footer;
                                }
                            }
                        }
                    }
                }
            });
        }

        function processWeeklyIncidentData(incidents, incidentTypes, severityFilter) {
            // Create weekly buckets for the last 12 months
            const now = new Date();
            const weeks = [];
            const weeklyData = {};
            
            // Generate last 52 weeks
            for (let i = 51; i >= 0; i--) {
                const weekStart = new Date(now.getTime() - (i * 7 * 24 * 60 * 60 * 1000));
                const weekEnd = new Date(weekStart.getTime() + (6 * 24 * 60 * 60 * 1000));
                
                // Create intuitive date range labels (e.g., "Jul 1-7", "Jul 8-14")
                const startMonth = weekStart.toLocaleDateString('en-US', {month: 'short'});
                const startDay = weekStart.getDate();
                const endDay = weekEnd.getDate();
                const endMonth = weekEnd.toLocaleDateString('en-US', {month: 'short'});
                
                // Handle cases where week spans across months
                let weekLabel;
                if (startMonth === endMonth) {
                    weekLabel = `${startMonth} ${startDay}-${endDay}`;
                } else {
                    weekLabel = `${startMonth} ${startDay}-${endMonth} ${endDay}`;
                }
                
                weeks.push({
                    label: weekLabel,
                    start: Math.floor(weekStart.getTime() / 1000),
                    end: Math.floor(weekEnd.getTime() / 1000)
                });
                
                weeklyData[weekLabel] = {};
                // Initialize all incident types and severities to 0
                Object.keys(incidentTypes).forEach(type => {
                    weeklyData[weekLabel][type] = { critical: 0, high: 0, medium: 0, low: 0 };
                });
            }
            
            // Categorize incidents into weekly buckets
            incidents.forEach(incident => {
                const incidentWeek = weeks.find(week => 
                    incident.startTime >= week.start && incident.startTime <= week.end
                );
                
                if (incidentWeek) {
                    let severityKey;
                    if (incident.severity === 0) severityKey = 'critical';
                    else if (incident.severity === 1) severityKey = 'high';
                    else if (incident.severity === 2) severityKey = 'medium';
                    else if (incident.severity === 3) severityKey = 'low';
                    else severityKey = 'low'; // Default fallback for unknown severity levels
                    
                    if (weeklyData[incidentWeek.label][incident.type]) {
                        weeklyData[incidentWeek.label][incident.type][severityKey]++;
                    }
                }
            });
            
            // Create datasets for chart
            const datasets = [];
            const chartLabels = weeks.map(week => week.label);
            
            Object.keys(incidentTypes).forEach(typeId => {
                const type = incidentTypes[typeId];
                
                if (severityFilter === 'critical' || severityFilter === 'critical-high' || severityFilter === 'critical-high-medium' || severityFilter === 'all') {
                    datasets.push({
                        label: `Critical ${type.name} ${type.icon}`,
                        data: weeks.map(week => weeklyData[week.label][typeId]?.critical || 0),
                        backgroundColor: type.criticalColor,
                        borderColor: type.criticalColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'Critical'
                    });
                }
                
                if (severityFilter === 'high' || severityFilter === 'critical-high' || severityFilter === 'critical-high-medium' || severityFilter === 'all') {
                    datasets.push({
                        label: `High ${type.name} ${type.icon}`,
                        data: weeks.map(week => weeklyData[week.label][typeId]?.high || 0),
                        backgroundColor: type.highColor,
                        borderColor: type.highColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'High'
                    });
                }
                
                if (severityFilter === 'medium' || severityFilter === 'critical-high-medium' || severityFilter === 'all') {
                    datasets.push({
                        label: `Medium ${type.name} ${type.icon}`,
                        data: weeks.map(week => weeklyData[week.label][typeId]?.medium || 0),
                        backgroundColor: type.mediumColor,
                        borderColor: type.mediumColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'Medium'
                    });
                }
                
                if (severityFilter === 'low' || severityFilter === 'all') {
                    datasets.push({
                        label: `Low ${type.name} ${type.icon}`,
                        data: weeks.map(week => weeklyData[week.label][typeId]?.low || 0),
                        backgroundColor: type.lowColor,
                        borderColor: type.lowColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'Low'
                    });
                }
            });
            
            return [datasets, chartLabels];
        }

        function processMonthlyIncidentData(incidents, incidentTypes, severityFilter, temperatureData = null) {
            // Create monthly buckets for the last 12 months
            const now = new Date();
            const months = [];
            const monthlyData = {};
            
            // Generate last 12 months
            for (let i = 11; i >= 0; i--) {
                const monthDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
                const monthLabel = monthDate.toLocaleDateString('en-US', {month: 'short', year: '2-digit'});
                const monthStart = Math.floor(monthDate.getTime() / 1000);
                const nextMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 1);
                const monthEnd = Math.floor(nextMonth.getTime() / 1000) - 1;
                
                months.push({
                    label: monthLabel,
                    start: monthStart,
                    end: monthEnd
                });
                
                monthlyData[monthLabel] = {};
                Object.keys(incidentTypes).forEach(type => {
                    monthlyData[monthLabel][type] = { critical: 0, high: 0, medium: 0, low: 0 };
                });
            }
            
            // Process temperature data if available
            let monthlyTemperatureStats = {};
            if (temperatureData) {
                monthlyTemperatureStats = aggregateTemperatureByMonth(temperatureData, months);
            }
            
            // Store temperature stats globally for tooltip access
            window.monthlyTemperatureStats = monthlyTemperatureStats;
            
            // Categorize incidents into monthly buckets
            incidents.forEach(incident => {
                const incidentMonth = months.find(month => 
                    incident.startTime >= month.start && incident.startTime <= month.end
                );
                
                if (incidentMonth) {
                    let severityKey;
                    if (incident.severity === 0) severityKey = 'critical';
                    else if (incident.severity === 1) severityKey = 'high';
                    else if (incident.severity === 2) severityKey = 'medium';
                    else if (incident.severity === 3) severityKey = 'low';
                    else severityKey = 'low'; // Default fallback for unknown severity levels
                    
                    if (monthlyData[incidentMonth.label][incident.type]) {
                        monthlyData[incidentMonth.label][incident.type][severityKey]++;
                    }
                }
            });
            
            // Create datasets for chart (same logic as weekly but with monthly data)
            const datasets = [];
            const chartLabels = months.map(month => month.label);
            
            Object.keys(incidentTypes).forEach(typeId => {
                const type = incidentTypes[typeId];
                
                if (severityFilter === 'critical' || severityFilter === 'critical-high' || severityFilter === 'critical-high-medium' || severityFilter === 'all') {
                    datasets.push({
                        label: `Critical ${type.name} ${type.icon}`,
                        data: months.map(month => monthlyData[month.label][typeId]?.critical || 0),
                        backgroundColor: type.criticalColor,
                        borderColor: type.criticalColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'Critical'
                    });
                }
                
                if (severityFilter === 'high' || severityFilter === 'critical-high' || severityFilter === 'critical-high-medium' || severityFilter === 'all') {
                    datasets.push({
                        label: `High ${type.name} ${type.icon}`,
                        data: months.map(month => monthlyData[month.label][typeId]?.high || 0),
                        backgroundColor: type.highColor,
                        borderColor: type.highColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'High'
                    });
                }
                
                if (severityFilter === 'medium' || severityFilter === 'critical-high-medium' || severityFilter === 'all') {
                    datasets.push({
                        label: `Medium ${type.name} ${type.icon}`,
                        data: months.map(month => monthlyData[month.label][typeId]?.medium || 0),
                        backgroundColor: type.mediumColor,
                        borderColor: type.mediumColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'Medium'
                    });
                }
                
                if (severityFilter === 'low' || severityFilter === 'all') {
                    datasets.push({
                        label: `Low ${type.name} ${type.icon}`,
                        data: months.map(month => monthlyData[month.label][typeId]?.low || 0),
                        backgroundColor: type.lowColor,
                        borderColor: type.lowColor,
                        borderWidth: 1,
                        incidentType: typeId,
                        severity: 'Low'
                    });
                }
            });
            
            // Add temperature overlay datasets for monthly view
            if (temperatureData && Object.keys(monthlyTemperatureStats).length > 0) {
                // Min temperature line
                datasets.push({
                    label: 'Min Temperature',
                    data: chartLabels.map(label => monthlyTemperatureStats[label] ? monthlyTemperatureStats[label].min : null),
                    type: 'line',
                    borderColor: '#3498db',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    yAxisID: 'yTemp',
                    tension: 0.4
                });
                
                // Max temperature line
                datasets.push({
                    label: 'Max Temperature',
                    data: chartLabels.map(label => monthlyTemperatureStats[label] ? monthlyTemperatureStats[label].max : null),
                    type: 'line',
                    borderColor: '#e74c3c',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    yAxisID: 'yTemp',
                    tension: 0.4
                });
                
                // Average temperature line
                datasets.push({
                    label: 'Avg Temperature',
                    data: chartLabels.map(label => monthlyTemperatureStats[label] ? monthlyTemperatureStats[label].avg : null),
                    type: 'line',
                    borderColor: '#f39c12',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    yAxisID: 'yTemp',
                    tension: 0.4,
                    borderDash: [5, 5]
                });
            }
            
            return [datasets, chartLabels];
        }

        // Aggregate temperature data by month
        function aggregateTemperatureByMonth(temperatureData, months) {
            const monthlyStats = {};
            
            months.forEach(month => {
                const monthData = temperatureData.filter(item => {
                    let timestamp;
                    
                    // Parse timestamp (same logic as chart validation)
                    if (typeof item.timestamp === 'string') {
                        if (item.timestamp.includes('T') || item.timestamp.includes('-')) {
                            timestamp = Math.floor(new Date(item.timestamp).getTime() / 1000);
                        } else {
                            timestamp = parseInt(item.timestamp);
                        }
                    } else if (typeof item.timestamp === 'number') {
                        timestamp = item.timestamp < 10000000000 ? item.timestamp : Math.floor(item.timestamp / 1000);
                    } else {
                        return false;
                    }
                    
                    return timestamp >= month.start && timestamp <= month.end;
                });
                
                if (monthData.length > 0) {
                    // Collect all valid temperature readings (indoor, outdoor, garage)
                    let allTemps = [];
                    
                    monthData.forEach(item => {
                        if (item.sensors) {
                            if (item.sensors.indoor && typeof item.sensors.indoor.temp === 'number') {
                                allTemps.push(item.sensors.indoor.temp);
                            }
                            if (item.sensors.outdoor && typeof item.sensors.outdoor.temp === 'number') {
                                allTemps.push(item.sensors.outdoor.temp);
                            }
                            if (item.sensors.garage && typeof item.sensors.garage.temp === 'number') {
                                allTemps.push(item.sensors.garage.temp);
                            }
                        }
                    });
                    
                    if (allTemps.length > 0) {
                        monthlyStats[month.label] = {
                            min: Math.round(Math.min(...allTemps) * 10) / 10,
                            max: Math.round(Math.max(...allTemps) * 10) / 10,
                            avg: Math.round((allTemps.reduce((sum, temp) => sum + temp, 0) / allTemps.length) * 10) / 10,
                            count: allTemps.length
                        };
                    }
                }
            });
            
            console.log('Monthly temperature stats:', monthlyStats);
            return monthlyStats;
        }

        // Helper function to get temperature stats for tooltip
        function getTemperatureStatsForTooltip(monthIndex, chartLabels) {
            if (window.monthlyTemperatureStats && chartLabels[monthIndex]) {
                const monthLabel = chartLabels[monthIndex];
                return window.monthlyTemperatureStats[monthLabel] || null;
            }
            return null;
        }

        function updateConnectionStatus(status) {
            const indicator = document.getElementById('connectionStatus');
            const text = document.getElementById('connectionText');

            switch(status) {
                case 'connected':
                    indicator.className = 'status-indicator online';
                    text.textContent = 'Connected';
                    break;
                case 'connecting':
                    indicator.className = 'status-indicator';
                    text.textContent = 'Connecting...';
                    break;
                case 'error':
                    indicator.className = 'status-indicator';
                    text.textContent = 'Connection Error';
                    break;
            }
        }

        function showError() {
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('dashboardContent').style.display = 'none';
            document.getElementById('errorSection').style.display = 'block';
        }

        function startAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
            }
            
            refreshTimer = setInterval(async () => {
                await refreshData();
            }, CONFIG.refreshInterval);
        }

        // Manual refresh function
        window.refreshData = refreshData;

        // Cooling effect calculation function
        function calculateCoolingEffect(indoorTemp, outdoorTemp, fanMinutes, fanCurrentlyOn) {
            // Return "No data" if we don't have the required temperatures
            if (indoorTemp == null || outdoorTemp == null || fanMinutes == null) {
                return 'No data';
            }

            // If fan hasn't run today, show that
            if (fanMinutes === 0) {
                return fanCurrentlyOn ? 'Starting...' : 'Not used today';
            }

            // Constants for 4500 CFM fan system
            const FAN_CFM = 4500; // Cubic feet per minute
            const AIR_DENSITY = 0.075; // lbs per cubic foot at standard conditions
            const SPECIFIC_HEAT_AIR = 0.24; // BTU per lb per ¬∞F
            const MINUTES_PER_HOUR = 60;

            // Calculate temperature difference (how much cooling potential exists)
            const tempDiff = indoorTemp - outdoorTemp;
            
            // If outdoor is warmer than indoor, show day's performance instead of "No cooling benefit"
            if (tempDiff <= 0) {
                if (fanCurrentlyOn) {
                    return 'Warming air';
                } else {
                    // Calculate and show today's comprehensive performance summary
                    const fanHours = (fanMinutes / 60).toFixed(1);
                    const dutyCycle = ((fanMinutes / (24 * 60)) * 100).toFixed(1);
                    
                    // More realistic BTU and temperature impact calculation
                    // Use conservative 2¬∞F average beneficial temperature difference
                    const avgBeneficialTempDiff = 2.0;
                    const airMassFlowRate = FAN_CFM * AIR_DENSITY;
                    const avgHeatTransferRate = airMassFlowRate * SPECIFIC_HEAT_AIR * avgBeneficialTempDiff * MINUTES_PER_HOUR;
                    const totalBTUsTransferred = avgHeatTransferRate * fanHours;
                    const btuDisplay = totalBTUsTransferred >= 1000 ? 
                        `${(totalBTUsTransferred / 1000).toFixed(1)}k BTU` : 
                        `${totalBTUsTransferred.toFixed(0)} BTU`;
                    
                    // Realistic net temperature impact accounting for heat gain
                    // During daytime operation, house gains heat from:
                    // - Solar gain: ~5-15¬∞F potential rise
                    // - Appliances: ~1-3¬∞F potential rise  
                    // - Thermal mass: Variable impact
                    const HOUSE_VOLUME_CF = 25000;
                    const houseAirMass = HOUSE_VOLUME_CF * AIR_DENSITY;
                    
                    // Calculate gross cooling potential
                    const grossCoolingPotential = totalBTUsTransferred / (houseAirMass * SPECIFIC_HEAT_AIR);
                    
                    // Apply realistic efficiency factors for net cooling achieved:
                    // - Air mixing efficiency: 50% (not perfect circulation)
                    // - Heat gain offset during operation: 80% (major reduction in cooling effectiveness)
                    // - Thermal mass absorption: 70% (walls/furniture absorb some cooling)
                    const netCoolingAchieved = grossCoolingPotential * 0.5 * 0.2 * 0.7; // ~7% net efficiency
                    
                    return `${fanHours}h runtime (${dutyCycle}% duty) ‚Ä¢ ~${btuDisplay} transferred ‚Ä¢ ~${netCoolingAchieved.toFixed(1)}¬∞F net cooling achieved`;
                }
            }

            // Calculate heat transfer rate (BTU/hr) when fan is running
            const airMassFlowRate = FAN_CFM * AIR_DENSITY; // lbs/min
            const heatTransferRate = airMassFlowRate * SPECIFIC_HEAT_AIR * tempDiff * MINUTES_PER_HOUR; // BTU/hr

            // Estimate HOURLY cooling rate (more realistic)
            // House volume ~25,000 cubic feet (including high ceilings)
            const HOUSE_VOLUME_CF = 25000;
            const houseAirMass = HOUSE_VOLUME_CF * AIR_DENSITY; // lbs of air in house
            
            // Calculate theoretical temperature drop per hour of continuous operation
            // This assumes perfect mixing and no heat gain during operation
            const hourlyTempDropPotential = heatTransferRate / (houseAirMass * SPECIFIC_HEAT_AIR); // ¬∞F/hr
            
            // Apply realistic efficiency factors:
            // - Air mixing efficiency: ~60% (not perfect mixing)
            // - Heat gain offset: ~40% (sun, appliances, thermal mass warming)
            const MIXING_EFFICIENCY = 0.6;
            const HEAT_GAIN_FACTOR = 0.4; // Reduces effective cooling
            
            const practicalHourlyRate = hourlyTempDropPotential * MIXING_EFFICIENCY * (1 - HEAT_GAIN_FACTOR);
            
            // Calculate average cooling rate based on actual usage pattern
            // If fan runs 50% of the time, effective rate is halved
            const operatingEfficiency = Math.min(fanMinutes / (60 * 16), 1.0); // Assume 16-hour operating window
            const effectiveHourlyRate = practicalHourlyRate * operatingEfficiency;

            // Format the results
            const heatTransferKBTU = (heatTransferRate / 1000).toFixed(1); // Convert to thousands of BTU/hr
            const hourlyRate = Math.min(effectiveHourlyRate, tempDiff * 0.5).toFixed(1); // Cap at 50% of temp difference

            // Create status message based on current state
            let status = '';
            if (fanCurrentlyOn) {
                status = ` (${heatTransferKBTU}k BTU/hr)`;
            } else {
                // Show comprehensive daily performance summary when fan is off
                const fanHours = (fanMinutes / 60).toFixed(1);
                const totalCooling = (effectiveHourlyRate * (fanMinutes / 60)).toFixed(1);
                
                // Calculate total BTUs transferred during operation
                const totalBTUsTransferred = heatTransferRate * (fanMinutes / 60);
                const btuDisplay = totalBTUsTransferred >= 1000 ? 
                    `${(totalBTUsTransferred / 1000).toFixed(1)}k BTU` : 
                    `${totalBTUsTransferred.toFixed(0)} BTU`;
                
                // Calculate current potential if fan were running now
                const currentPotentialBTU = (heatTransferRate / 1000).toFixed(1);
                
                status = ` (${fanHours}h today ‚Ä¢ ${btuDisplay} transferred ‚Ä¢ ${totalCooling}¬∞F achieved ‚Ä¢ ${currentPotentialBTU}k BTU/hr potential)`;
            }

            return `~${hourlyRate}¬∞F/hr rate${status}`;
        }
    </script>

    <!-- Discrete Build Info Footer -->
    <div style="position: fixed; bottom: 5px; right: 10px; font-size: 12px; color: #555; font-family: monospace; z-index: 1000; background: rgba(255,255,255,0.8); padding: 2px 6px; border-radius: 3px;">
        Build: <span id="buildInfo">2025.07.29-1600-garage-data-display</span>
    </div>
</body>
</html>
